/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _SYS_SOCKET_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOL_MPTCP: u32 = 284;
pub const SOL_MCTP: u32 = 285;
pub const SOL_SMC: u32 = 286;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SO_PASSPIDFD: u32 = 76;
pub const SO_PEERPIDFD: u32 = 77;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const VRT_INTEGER_MAX: u64 = 999999999999999;
pub const VRT_INTEGER_MIN: i64 = -999999999999999;
pub const VRT_MAJOR_VERSION: u32 = 19;
pub const VRT_MINOR_VERSION: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const VRT_NULL_BLOB_TYPE: u32 = 4208873376;
pub const VRT_CTX_MAGIC: u32 = 1807282395;
pub const VRT_ENDPOINT_MAGIC: u32 = 3426849607;
pub const VRT_BACKEND_MAGIC: u32 = 1201262188;
pub const VRT_BACKEND_PROBE_MAGIC: u32 = 2224653456;
pub const VDI_METHODS_MAGIC: u32 = 1321256123;
pub const DIRECTOR_MAGIC: u32 = 859190557;
pub const VMOD_PRIV_METHODS_MAGIC: u32 = 3466985369;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const VSPLAY_NEGINF: i32 = -1;
pub const VSPLAY_INF: u32 = 1;
pub const VRBT_STRICT_HST: u32 = 0;
pub const VRBT_NEGINF: i32 = -1;
pub const VRBT_INF: u32 = 1;
pub const VSL_CLASS: &[u8; 4usize] = b"Log\0";
pub const VSL_SEGMENTS: u32 = 8;
pub const VSL_CLIENTMARKER: u64 = 4611686018427387904;
pub const VSL_BACKENDMARKER: i64 = -9223372036854775808;
pub const VSL_IDENTMASK: u64 = 2251799813685247;
pub const VSL_LENMASK: u32 = 65535;
pub const VSL_VERMASK: u32 = 3;
pub const VSL_VERSHIFT: u32 = 16;
pub const VSL_IDMASK: u32 = 255;
pub const VSL_IDSHIFT: u32 = 24;
pub const VSL_OVERHEAD: u32 = 3;
pub const VSL_VERSION_2: u32 = 0;
pub const VSL_VERSION_3: u32 = 1;
pub const SLT__MAX: u32 = 256;
pub const NODEF_NOTICE: &[u8; 44usize] = b"NB: This log record is masked by default.\n\n\0";
pub const NOSUP_NOTICE : & [u8 ; 171usize] = b"NOTE: This tag is currently not in use in the Varnish log.\nIt is mentioned here to document legacy versions of the log,\nor reserved for possible use in future versions.\n\n\0" ;
pub const HEADER_NOTICE : & [u8 ; 189usize] = b"NOTE: HTTP header fields are free form records and not strictly\nmade of 2 fields. Accessing a specific header with the prefix\nnotation helps treating the header value as a single string.\n\n\0" ;
pub const SLT_F_UNUSED: u32 = 1;
pub const SLT_F_UNSAFE: u32 = 2;
pub const SLT_F_BINARY: u32 = 4;
pub const STREAM_CLOSE_MAGIC: u32 = 3363424573;
pub const DIGEST_LEN: u32 = 32;
pub const WS_ID_SIZE: u32 = 4;
pub const WS_MAGIC: u32 = 905626964;
pub const HTTP_MAGIC: u32 = 1680389577;
pub const HDF_FILTER: u32 = 1;
pub const WORKER_MAGIC: u32 = 1670491599;
pub const BOC_MAGIC: u32 = 1892254838;
pub const OBJCORE_MAGIC: u32 = 1294996226;
pub const BUSYOBJ_MAGIC: u32 = 599348583;
pub const REQTOP_MAGIC: u32 = 1476123218;
pub const REQ_MAGIC: u32 = 4215979885;
pub const RES_ESI: u32 = 16;
pub const RES_PIPE: u32 = 128;
pub const SESS_MAGIC: u32 = 741317722;
pub const HTTPH_R_PASS: u32 = 1;
pub const HTTPH_R_FETCH: u32 = 2;
pub const HTTPH_A_INS: u32 = 4;
pub const HTTPH_A_PASS: u32 = 8;
pub const HTTPH_C_SPECIFIC: u32 = 16;
pub const P: u32 = 1;
pub const F: u32 = 2;
pub const I: u32 = 4;
pub const S: u32 = 8;
pub const K: u32 = 16;
pub const OBJ_ITER_FLUSH: u32 = 1;
pub const OBJ_ITER_END: u32 = 2;
pub const VCLDIR_MAGIC: u32 = 3211947133;
pub const VDIR_FLG_NOREFCNT: u32 = 1;
pub const VFP_ENTRY_MAGIC: u32 = 3190988839;
pub const VFP_CTX_MAGIC: u32 = 1641665509;
pub const VDP_ENTRY_MAGIC: u32 = 893302657;
pub const VDP_CTX_MAGIC: u32 = 3998227959;
pub const VMOD_ABI_Version: &[u8; 55usize] =
    b"Varnish 7.5.0 eef25264e5ca5f96a77129308edb83ccf84cb1b1\0";
pub const VSB_MAGIC: u32 = 1250090378;
pub const VSB_FIXEDLEN: u32 = 0;
pub const VSB_AUTOEXTEND: u32 = 1;
pub const VSB_USRFLAGMSK: u32 = 65535;
pub const VSB_DYNAMIC: u32 = 65536;
pub const VSB_FINISHED: u32 = 131072;
pub const VSB_DYNSTRUCT: u32 = 524288;
pub const VSB_QUOTE_PLAIN: u32 = 0;
pub const VSB_QUOTE_JSON: u32 = 2;
pub const VSB_QUOTE_HEX: u32 = 4;
pub const VSB_QUOTE_CSTR: u32 = 8;
pub const VSB_QUOTE_UNSAFE: u32 = 16;
pub const VSB_QUOTE_NONL: u32 = 1;
pub const VSB_QUOTE_ESCHEX: u32 = 32;
pub const VSM_n_USAGE: &[u8; 18usize] = b"[-n varnish_name]\0";
pub const VSM_t_USAGE: &[u8; 19usize] = b"[-t <seconds|off>]\0";
pub const VSM_MGT_RUNNING: u32 = 2;
pub const VSM_MGT_CHANGED: u32 = 4;
pub const VSM_MGT_RESTARTED: u32 = 8;
pub const VSM_WRK_RUNNING: u32 = 512;
pub const VSM_WRK_CHANGED: u32 = 1024;
pub const VSM_WRK_RESTARTED: u32 = 2048;
pub const HTTP_CONN_MAGIC: u32 = 1041886673;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MSG_OOB: _bindgen_ty_1 = 1;
pub const MSG_PEEK: _bindgen_ty_1 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_1 = 4;
pub const MSG_CTRUNC: _bindgen_ty_1 = 8;
pub const MSG_PROXY: _bindgen_ty_1 = 16;
pub const MSG_TRUNC: _bindgen_ty_1 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_1 = 64;
pub const MSG_EOR: _bindgen_ty_1 = 128;
pub const MSG_WAITALL: _bindgen_ty_1 = 256;
pub const MSG_FIN: _bindgen_ty_1 = 512;
pub const MSG_SYN: _bindgen_ty_1 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_1 = 2048;
pub const MSG_RST: _bindgen_ty_1 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_1 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_1 = 16384;
pub const MSG_MORE: _bindgen_ty_1 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_1 = 65536;
pub const MSG_BATCH: _bindgen_ty_1 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_1 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_1 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_1 = 1073741824;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cmsg_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<osockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: _bindgen_ty_3 = 0;
pub const SHUT_WR: _bindgen_ty_3 = 1;
pub const SHUT_RDWR: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_4 = 0;
pub const FP_INFINITE: _bindgen_ty_4 = 1;
pub const FP_ZERO: _bindgen_ty_4 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_4 = 3;
pub const FP_NORMAL: _bindgen_ty_4 = 4;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_5 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_5 = 1;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_6 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_6 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_6 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_6 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_6 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_6 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_6 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_6 = 0;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_7 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_7 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_7 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_8 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_8 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_9 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_9 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_9 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_9 = 0;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_10 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_11 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_12 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_12 = 1;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
impl Default for _pthread_cleanup_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_13 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_14 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_14 = 1;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__cancel_jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
impl Default for __pthread_unwind_buf_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
impl Default for __pthread_cleanup_frame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type vtim_mono = f64;
pub type vtim_real = f64;
pub type vtim_dur = f64;
#[doc = " txt (vas.h needed for the macros)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct txt {
    pub b: *const ::std::os::raw::c_char,
    pub e: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_txt() {
    const UNINIT: ::std::mem::MaybeUninit<txt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<txt>(),
        16usize,
        concat!("Size of: ", stringify!(txt))
    );
    assert_eq!(
        ::std::mem::align_of::<txt>(),
        8usize,
        concat!("Alignment of ", stringify!(txt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(txt), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(txt), "::", stringify!(e))
    );
}
impl Default for txt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stevedore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct suckaddr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_conf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcl_sub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_main {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsc_seg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsmw_cluster {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wrk_vpi {
    _unused: [u8; 0],
}
pub type stream_close_t = *const stream_close;
#[doc = " VCL_STRANDS:\n\n An argc+argv type of data structure where n indicates the number of\n strings in the p array. Individual components of a strands may be null.\n\n A STRANDS allows you to work on a strings concatenation with the\n option to collect it into a single STRING, or if possible work\n directly on individual parts.\n\n The memory management is very strict: a VMOD function receiving a\n STRANDS argument should keep no reference after the function returns.\n Retention of a STRANDS further in the ongoing task is undefined\n behavior and may result in a panic or data corruption."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strands {
    pub n: ::std::os::raw::c_int,
    pub p: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_strands() {
    const UNINIT: ::std::mem::MaybeUninit<strands> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<strands>(),
        16usize,
        concat!("Size of: ", stringify!(strands))
    );
    assert_eq!(
        ::std::mem::align_of::<strands>(),
        8usize,
        concat!("Alignment of ", stringify!(strands))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(strands),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(strands),
            "::",
            stringify!(p)
        )
    );
}
impl Default for strands {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut vrt_null_strands: *const strands;
}
#[doc = " VCL_BLOB:\n\n Opaque, immutable data (pointer + length), minimum lifetime is the\n VCL task.\n\n Type (optional) is owned by the creator of the blob. blob consumers\n may use it for checks, but should not assert on it.\n\n The data behind the blob pointer is assumed to be immutable for the\n blob's lifetime.\n\n - memory for shortlived blobs can be put on the tasks workspace\n\n - management of memory for longer lived blobs is up to the vmod\n   (in which case the blob will probably be embedded in an object or\n    referenced by other state with vcl lifetime)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_blob {
    pub type_: ::std::os::raw::c_uint,
    pub len: usize,
    pub blob: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vrt_blob() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_blob> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_blob>(),
        24usize,
        concat!("Size of: ", stringify!(vrt_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_blob))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_blob),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_blob),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_blob),
            "::",
            stringify!(blob)
        )
    );
}
impl Default for vrt_blob {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut vrt_null_blob: *const vrt_blob;
}
#[doc = " This is the central definition of the mapping from VCL types to\n C-types.  The python scripts read these from here.\n (keep alphabetic order)"]
pub type VCL_ACL = *const vrt_acl;
pub type VCL_BACKEND = *const director;
pub type VCL_BLOB = *const vrt_blob;
pub type VCL_BODY = *const ::std::os::raw::c_void;
pub type VCL_BOOL = ::std::os::raw::c_uint;
pub type VCL_BYTES = i64;
pub type VCL_DURATION = vtim_dur;
pub type VCL_ENUM = *const ::std::os::raw::c_char;
pub type VCL_HEADER = *const gethdr_s;
pub type VCL_HTTP = *mut http;
pub type VCL_INSTANCE = ::std::os::raw::c_void;
pub type VCL_INT = i64;
pub type VCL_IP = *const suckaddr;
pub type VCL_PROBE = *const vrt_backend_probe;
pub type VCL_REAL = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vre {
    _unused: [u8; 0],
}
pub type VCL_REGEX = *const vre;
pub type VCL_STEVEDORE = *const stevedore;
pub type VCL_STRANDS = *const strands;
pub type VCL_STRING = *const ::std::os::raw::c_char;
pub type VCL_SUB = *const vcl_sub;
pub type VCL_TIME = vtim_real;
pub type VCL_VCL = *mut vcl;
pub type VCL_VOID = ::std::os::raw::c_void;
#[doc = " This is the composite \"context\" argument for compiled VCL, VRT and\n VMOD functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub syntax: ::std::os::raw::c_uint,
    pub vclver: ::std::os::raw::c_uint,
    pub method: ::std::os::raw::c_uint,
    pub vpi: *mut wrk_vpi,
    pub msg: *mut vsb,
    pub vsl: *mut vsl_log,
    pub vcl: VCL_VCL,
    pub ws: *mut ws,
    pub sp: *mut sess,
    pub req: *mut req,
    pub http_req: VCL_HTTP,
    pub http_req_top: VCL_HTTP,
    pub http_resp: VCL_HTTP,
    pub bo: *mut busyobj,
    pub http_bereq: VCL_HTTP,
    pub http_beresp: VCL_HTTP,
    pub now: vtim_real,
    pub specific: *mut ::std::os::raw::c_void,
    pub called: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vrt_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_ctx>(),
        144usize,
        concat!("Size of: ", stringify!(vrt_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syntax) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vclver) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vclver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vpi) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vpi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(ws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_req) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_req_top) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_req_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_resp) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bo) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(bo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_bereq) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_bereq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_beresp) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_beresp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).now) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(now)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).specific) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(specific)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).called) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(called)
        )
    );
}
impl Default for vrt_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_CTX_Assert(ctx: *const vrt_ctx);
}
pub const vcl_func_call_e_VSUB_STATIC: vcl_func_call_e = 0;
pub const vcl_func_call_e_VSUB_DYNAMIC: vcl_func_call_e = 1;
pub const vcl_func_call_e_VSUB_CHECK: vcl_func_call_e = 2;
pub type vcl_func_call_e = ::std::os::raw::c_uint;
pub const vcl_func_fail_e_VSUB_E_OK: vcl_func_fail_e = 0;
pub const vcl_func_fail_e_VSUB_E_RECURSE: vcl_func_fail_e = 1;
pub const vcl_func_fail_e_VSUB_E_METHOD: vcl_func_fail_e = 2;
pub type vcl_func_fail_e = ::std::os::raw::c_uint;
pub type vcl_func_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: vcl_func_call_e, arg2: *mut vcl_func_fail_e),
>;
#[doc = " This is the interface structure to a compiled VMOD\n (produced by vmodtool.py)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_data {
    pub vrt_major: ::std::os::raw::c_uint,
    pub vrt_minor: ::std::os::raw::c_uint,
    pub file_id: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub func_name: *const ::std::os::raw::c_char,
    pub func: *const ::std::os::raw::c_void,
    pub func_len: ::std::os::raw::c_int,
    pub proto: *const ::std::os::raw::c_char,
    pub json: *const ::std::os::raw::c_char,
    pub abi: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_vmod_data() {
    const UNINIT: ::std::mem::MaybeUninit<vmod_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vmod_data>(),
        72usize,
        concat!("Size of: ", stringify!(vmod_data))
    );
    assert_eq!(
        ::std::mem::align_of::<vmod_data>(),
        8usize,
        concat!("Alignment of ", stringify!(vmod_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vrt_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(vrt_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vrt_minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(vrt_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(file_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(func_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(func_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).json) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(json)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abi) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(abi)
        )
    );
}
impl Default for vmod_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vcl_event_e_VCL_EVENT_LOAD: vcl_event_e = 0;
pub const vcl_event_e_VCL_EVENT_WARM: vcl_event_e = 1;
pub const vcl_event_e_VCL_EVENT_COLD: vcl_event_e = 2;
pub const vcl_event_e_VCL_EVENT_DISCARD: vcl_event_e = 3;
#[doc = " VCL events sent to VMODs"]
pub type vcl_event_e = ::std::os::raw::c_uint;
pub type vmod_event_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: *mut vmod_priv,
        arg2: vcl_event_e,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Utility functions operating on VCL_types\n (alphabetic by type-ish)"]
    pub fn VRT_acl_match(ctx: *const vrt_ctx, arg1: VCL_ACL, arg2: VCL_IP)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_DirectorResolve(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_blob(
        ctx: *const vrt_ctx,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_uint,
    ) -> VCL_BLOB;
}
extern "C" {
    pub fn VRT_INT_is_valid(arg1: VCL_INT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_VSA_GetPtr(
        ctx: *const vrt_ctx,
        sua: VCL_IP,
        dst: *mut *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_ipcmp(ctx: *const vrt_ctx, arg1: VCL_IP, arg2: VCL_IP) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_Format_Proxy(
        arg1: *mut vsb,
        arg2: VCL_INT,
        arg3: VCL_IP,
        arg4: VCL_IP,
        arg5: VCL_STRING,
    );
}
extern "C" {
    pub fn VRT_REAL_is_valid(arg1: VCL_REAL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_re_match(ctx: *const vrt_ctx, arg1: VCL_STRING, arg2: VCL_REGEX) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_regsub(
        ctx: *const vrt_ctx,
        all: ::std::os::raw::c_int,
        arg1: VCL_STRING,
        arg2: VCL_REGEX,
        arg3: VCL_STRING,
    ) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_stevedore(nm: *const ::std::os::raw::c_char) -> VCL_STEVEDORE;
}
extern "C" {
    pub fn VRT_AllocStrandsWS(arg1: *mut ws, arg2: ::std::os::raw::c_int) -> *mut strands;
}
extern "C" {
    pub fn VRT_CompareStrands(a: VCL_STRANDS, b: VCL_STRANDS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_Strands2Bool(arg1: VCL_STRANDS) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_HashStrands32(arg1: VCL_STRANDS) -> u32;
}
extern "C" {
    pub fn VRT_Strands(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: VCL_STRANDS,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn VRT_StrandsWS(
        arg1: *mut ws,
        arg2: *const ::std::os::raw::c_char,
        arg3: VCL_STRANDS,
    ) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_UpperLowerStrands(
        ctx: *const vrt_ctx,
        s: VCL_STRANDS,
        up: ::std::os::raw::c_int,
    ) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_check_call(ctx: *const vrt_ctx, arg1: VCL_SUB) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_call(ctx: *const vrt_ctx, arg1: VCL_SUB);
}
extern "C" {
    pub fn VRT_BACKEND_string(arg1: VCL_BACKEND) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_BOOL_string(arg1: VCL_BOOL) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_BLOB_string(ctx: *const vrt_ctx, arg1: VCL_BLOB) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_INT_string(ctx: *const vrt_ctx, arg1: VCL_INT) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_IP_string(ctx: *const vrt_ctx, arg1: VCL_IP) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_REAL_string(ctx: *const vrt_ctx, arg1: VCL_REAL) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_STEVEDORE_string(arg1: VCL_STEVEDORE) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_STRANDS_string(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_TIME_string(ctx: *const vrt_ctx, arg1: VCL_TIME) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_strcmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_memmove(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    );
}
#[doc = " We want the VCC to spit this structs out as const, but when VMODs\n come up with them we want to clone them into malloc'ed space which\n we can free again.\n We collect all the knowledge here by macroizing the fields and make\n a macro for handling them all.\n See also:  cache_backend.h & cache_backend_cfg.c\n One of those things..."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_endpoint {
    pub magic: ::std::os::raw::c_uint,
    pub ipv4: VCL_IP,
    pub ipv6: VCL_IP,
    pub uds_path: *const ::std::os::raw::c_char,
    pub preamble: *const vrt_blob,
}
#[test]
fn bindgen_test_layout_vrt_endpoint() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_endpoint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_endpoint>(),
        40usize,
        concat!("Size of: ", stringify!(vrt_endpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_endpoint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(ipv6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uds_path) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(uds_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preamble) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(preamble)
        )
    );
}
impl Default for vrt_endpoint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_backend {
    pub magic: ::std::os::raw::c_uint,
    pub endpoint: *const vrt_endpoint,
    pub vcl_name: *const ::std::os::raw::c_char,
    pub hosthdr: *const ::std::os::raw::c_char,
    pub authority: *const ::std::os::raw::c_char,
    pub connect_timeout: vtim_dur,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
    pub max_connections: ::std::os::raw::c_uint,
    pub proxy_header: ::std::os::raw::c_uint,
    pub probe: VCL_PROBE,
}
#[test]
fn bindgen_test_layout_vrt_backend() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_backend> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_backend>(),
        80usize,
        concat!("Size of: ", stringify!(vrt_backend))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_backend>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_backend))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(vcl_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hosthdr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(hosthdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authority) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(authority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_timeout) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(connect_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_byte_timeout) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(first_byte_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).between_bytes_timeout) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(between_bytes_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_connections) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(max_connections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proxy_header) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(proxy_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).probe) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(probe)
        )
    );
}
impl Default for vrt_backend {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_backend_probe {
    pub magic: ::std::os::raw::c_uint,
    pub url: *const ::std::os::raw::c_char,
    pub request: *const ::std::os::raw::c_char,
    pub timeout: vtim_dur,
    pub interval: vtim_dur,
    pub exp_status: ::std::os::raw::c_uint,
    pub window: ::std::os::raw::c_uint,
    pub threshold: ::std::os::raw::c_uint,
    pub initial: ::std::os::raw::c_uint,
    pub exp_close: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vrt_backend_probe() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_backend_probe> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_backend_probe>(),
        64usize,
        concat!("Size of: ", stringify!(vrt_backend_probe))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_backend_probe>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_backend_probe))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).url) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exp_status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(exp_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(initial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exp_close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(exp_close)
        )
    );
}
impl Default for vrt_backend_probe {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_new_backend(
        ctx: *const vrt_ctx,
        arg1: *const vrt_backend,
        arg2: VCL_BACKEND,
    ) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_new_backend_clustered(
        ctx: *const vrt_ctx,
        arg1: *mut vsmw_cluster,
        arg2: *const vrt_backend,
        arg3: VCL_BACKEND,
    ) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_backend_vsm_need(ctx: *const vrt_ctx) -> usize;
}
extern "C" {
    pub fn VRT_delete_backend(ctx: *const vrt_ctx, arg1: *mut VCL_BACKEND);
}
extern "C" {
    pub fn VRT_Endpoint_Clone(vep: *const vrt_endpoint) -> *mut vrt_endpoint;
}
pub const gethdr_e_HDR_REQ: gethdr_e = 0;
pub const gethdr_e_HDR_REQ_TOP: gethdr_e = 1;
pub const gethdr_e_HDR_RESP: gethdr_e = 2;
pub const gethdr_e_HDR_OBJ: gethdr_e = 3;
pub const gethdr_e_HDR_BEREQ: gethdr_e = 4;
pub const gethdr_e_HDR_BERESP: gethdr_e = 5;
#[doc = " Getting hold of the various struct http"]
pub type gethdr_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gethdr_s {
    pub where_: gethdr_e,
    pub what: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_gethdr_s() {
    const UNINIT: ::std::mem::MaybeUninit<gethdr_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gethdr_s>(),
        16usize,
        concat!("Size of: ", stringify!(gethdr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<gethdr_s>(),
        8usize,
        concat!("Alignment of ", stringify!(gethdr_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).where_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gethdr_s),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).what) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gethdr_s),
            "::",
            stringify!(what)
        )
    );
}
impl Default for gethdr_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_selecthttp(ctx: *const vrt_ctx, arg1: gethdr_e) -> VCL_HTTP;
}
extern "C" {
    pub fn VRT_GetHdr(ctx: *const vrt_ctx, arg1: VCL_HEADER) -> VCL_STRING;
}
pub const lbody_e_LBODY_SET_STRING: lbody_e = 0;
pub const lbody_e_LBODY_ADD_STRING: lbody_e = 1;
pub const lbody_e_LBODY_SET_BLOB: lbody_e = 2;
pub const lbody_e_LBODY_ADD_BLOB: lbody_e = 3;
#[doc = " req related"]
pub type lbody_e = ::std::os::raw::c_uint;
extern "C" {
    pub fn VRT_CacheReqBody(ctx: *const vrt_ctx, maxsize: VCL_BYTES) -> VCL_BYTES;
}
extern "C" {
    pub fn VRT_ban_string(ctx: *const vrt_ctx, arg1: VCL_STRING) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_purge(
        ctx: *const vrt_ctx,
        arg1: VCL_DURATION,
        arg2: VCL_DURATION,
        arg3: VCL_DURATION,
    ) -> VCL_INT;
}
extern "C" {
    pub fn VRT_synth(ctx: *const vrt_ctx, arg1: VCL_INT, arg2: VCL_STRING);
}
extern "C" {
    pub fn VRT_hit_for_pass(ctx: *const vrt_ctx, arg1: VCL_DURATION);
}
extern "C" {
    pub fn VRT_ValidHdr(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_UnsetHdr(ctx: *const vrt_ctx, arg1: VCL_HEADER);
}
extern "C" {
    pub fn VRT_SetHdr(
        ctx: *const vrt_ctx,
        arg1: VCL_HEADER,
        pfx: *const ::std::os::raw::c_char,
        arg2: VCL_STRANDS,
    );
}
extern "C" {
    pub fn VRT_handling(ctx: *const vrt_ctx, hand: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn VRT_handled(ctx: *const vrt_ctx) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn VRT_trace(ctx: *const vrt_ctx, arg1: VCL_BOOL);
}
extern "C" {
    pub fn VRT_fail(ctx: *const vrt_ctx, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VRT_hashdata(ctx: *const vrt_ctx, arg1: VCL_STRANDS);
}
extern "C" {
    pub fn VRT_Rollback(ctx: *const vrt_ctx, arg1: VCL_HTTP);
}
extern "C" {
    pub fn VRT_synth_strands(ctx: *const vrt_ctx, arg1: VCL_STRANDS);
}
extern "C" {
    pub fn VRT_synth_blob(ctx: *const vrt_ctx, arg1: VCL_BLOB);
}
#[doc = " VDI - Director API"]
pub type vdi_healthy_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND, arg2: *mut VCL_TIME) -> VCL_BOOL,
>;
pub type vdi_resolve_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> VCL_BACKEND,
>;
pub type vdi_gethdrs_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> ::std::os::raw::c_int,
>;
pub type vdi_getip_f =
    ::std::option::Option<unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> VCL_IP>;
pub type vdi_finish_f =
    ::std::option::Option<unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND)>;
pub type vdi_http1pipe_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> stream_close_t,
>;
pub type vdi_event_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND, arg2: vcl_event_e)>;
pub type vdi_release_f = ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND)>;
pub type vdi_destroy_f = ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND)>;
pub type vdi_panic_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND, arg2: *mut vsb)>;
pub type vdi_list_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: VCL_BACKEND,
        arg2: *mut vsb,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdi_methods {
    pub magic: ::std::os::raw::c_uint,
    pub type_: *const ::std::os::raw::c_char,
    pub http1pipe: vdi_http1pipe_f,
    pub healthy: vdi_healthy_f,
    pub resolve: vdi_resolve_f,
    pub gethdrs: vdi_gethdrs_f,
    pub getip: vdi_getip_f,
    pub finish: vdi_finish_f,
    pub event: vdi_event_f,
    pub release: vdi_release_f,
    pub destroy: vdi_destroy_f,
    pub panic: vdi_panic_f,
    pub list: vdi_list_f,
}
#[test]
fn bindgen_test_layout_vdi_methods() {
    const UNINIT: ::std::mem::MaybeUninit<vdi_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdi_methods>(),
        104usize,
        concat!("Size of: ", stringify!(vdi_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<vdi_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(vdi_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http1pipe) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(http1pipe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).healthy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(healthy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolve) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(resolve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gethdrs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(gethdrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getip) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(getip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finish) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).panic) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(panic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(list)
        )
    );
}
impl Default for vdi_methods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct director {
    pub magic: ::std::os::raw::c_uint,
    pub priv_: *mut ::std::os::raw::c_void,
    pub vcl_name: *mut ::std::os::raw::c_char,
    pub vdir: *mut vcldir,
    pub mtx: *mut lock,
}
#[test]
fn bindgen_test_layout_director() {
    const UNINIT: ::std::mem::MaybeUninit<director> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<director>(),
        40usize,
        concat!("Size of: ", stringify!(director))
    );
    assert_eq!(
        ::std::mem::align_of::<director>(),
        8usize,
        concat!("Alignment of ", stringify!(director))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(vcl_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdir) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(vdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(mtx)
        )
    );
}
impl Default for director {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_Healthy(ctx: *const vrt_ctx, arg1: VCL_BACKEND, arg2: *mut VCL_TIME) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_SetChanged(arg1: VCL_BACKEND, arg2: VCL_TIME);
}
extern "C" {
    pub fn VRT_AddDirector(
        ctx: *const vrt_ctx,
        arg1: *const vdi_methods,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_DisableDirector(arg1: VCL_BACKEND);
}
extern "C" {
    pub fn VRT_StaticDirector(arg1: VCL_BACKEND);
}
extern "C" {
    pub fn VRT_LookupDirector(ctx: *const vrt_ctx, arg1: VCL_STRING) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_DelDirector(arg1: *mut VCL_BACKEND);
}
extern "C" {
    pub fn VRT_Assign_Backend(dst: *mut VCL_BACKEND, src: VCL_BACKEND);
}
#[doc = " vmod_priv related"]
pub type vmod_priv_fini_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_priv_methods {
    pub magic: ::std::os::raw::c_uint,
    pub type_: *const ::std::os::raw::c_char,
    pub fini: vmod_priv_fini_f,
}
#[test]
fn bindgen_test_layout_vmod_priv_methods() {
    const UNINIT: ::std::mem::MaybeUninit<vmod_priv_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vmod_priv_methods>(),
        24usize,
        concat!("Size of: ", stringify!(vmod_priv_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<vmod_priv_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(vmod_priv_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv_methods),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv_methods),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fini) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv_methods),
            "::",
            stringify!(fini)
        )
    );
}
impl Default for vmod_priv_methods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_priv {
    pub priv_: *mut ::std::os::raw::c_void,
    pub len: ::std::os::raw::c_long,
    pub methods: *const vmod_priv_methods,
}
#[test]
fn bindgen_test_layout_vmod_priv() {
    const UNINIT: ::std::mem::MaybeUninit<vmod_priv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vmod_priv>(),
        24usize,
        concat!("Size of: ", stringify!(vmod_priv))
    );
    assert_eq!(
        ::std::mem::align_of::<vmod_priv>(),
        8usize,
        concat!("Alignment of ", stringify!(vmod_priv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).methods) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv),
            "::",
            stringify!(methods)
        )
    );
}
impl Default for vmod_priv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_priv_fini(ctx: *const vrt_ctx, p: *const vmod_priv);
}
extern "C" {
    pub fn VRT_priv_task(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    pub fn VRT_priv_task_get(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    pub fn VRT_priv_top(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    pub fn VRT_priv_top_get(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    #[doc = " VSM and VSC"]
    pub fn VRT_VSM_Cluster_New(ctx: *const vrt_ctx, arg1: usize) -> *mut vsmw_cluster;
}
extern "C" {
    pub fn VRT_VSM_Cluster_Destroy(ctx: *const vrt_ctx, arg1: *mut *mut vsmw_cluster);
}
extern "C" {
    pub fn VRT_VSC_Alloc(
        arg1: *mut vsmw_cluster,
        arg2: *mut *mut vsc_seg,
        arg3: *const ::std::os::raw::c_char,
        arg4: usize,
        arg5: *const ::std::os::raw::c_uchar,
        arg6: usize,
        arg7: *const ::std::os::raw::c_char,
        arg8: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn VRT_VSC_Destroy(arg1: *const ::std::os::raw::c_char, arg2: *mut vsc_seg);
}
extern "C" {
    pub fn VRT_VSC_Hide(arg1: *const vsc_seg);
}
extern "C" {
    pub fn VRT_VSC_Reveal(arg1: *const vsc_seg);
}
extern "C" {
    pub fn VRT_VSC_Overhead(arg1: usize) -> usize;
}
#[doc = " API to restrict the VCL in various ways"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vclref {
    _unused: [u8; 0],
}
extern "C" {
    pub fn VRT_VCL_Prevent_Cold(
        ctx: *const vrt_ctx,
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut vclref;
}
extern "C" {
    pub fn VRT_VCL_Allow_Cold(arg1: *mut *mut vclref);
}
extern "C" {
    pub fn VRT_VCL_Prevent_Discard(
        ctx: *const vrt_ctx,
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut vclref;
}
extern "C" {
    pub fn VRT_VCL_Allow_Discard(arg1: *mut *mut vclref);
}
extern "C" {
    #[doc = " Deprecated interfaces, do not use, they will disappear at some point."]
    pub fn VRT_synth_page(ctx: *const vrt_ctx, arg1: VCL_STRANDS);
}
extern "C" {
    pub fn VRT_Stv(nm: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn VAS_errtxt(e: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub const vas_e_VAS_WRONG: vas_e = 0;
pub const vas_e_VAS_MISSING: vas_e = 1;
pub const vas_e_VAS_ASSERT: vas_e = 2;
pub const vas_e_VAS_INCOMPLETE: vas_e = 3;
pub const vas_e_VAS_VCL: vas_e = 4;
pub type vas_e = ::std::os::raw::c_uint;
pub type vas_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: vas_e,
    ),
>;
extern "C" {
    pub static mut VAS_Fail_Func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *const ::std::os::raw::c_char,
            arg5: vas_e,
        ) -> !,
    >;
}
extern "C" {
    pub fn VAS_Fail(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: vas_e,
    ) -> !;
}
pub const VSL_tag_e_SLT__Bogus: VSL_tag_e = 0;
pub const VSL_tag_e_SLT_Debug: VSL_tag_e = 1;
pub const VSL_tag_e_SLT_Error: VSL_tag_e = 2;
pub const VSL_tag_e_SLT_CLI: VSL_tag_e = 3;
pub const VSL_tag_e_SLT_SessOpen: VSL_tag_e = 4;
pub const VSL_tag_e_SLT_SessClose: VSL_tag_e = 5;
pub const VSL_tag_e_SLT_BackendOpen: VSL_tag_e = 6;
pub const VSL_tag_e_SLT_BackendClose: VSL_tag_e = 7;
pub const VSL_tag_e_SLT_HttpGarbage: VSL_tag_e = 8;
pub const VSL_tag_e_SLT_Proxy: VSL_tag_e = 9;
pub const VSL_tag_e_SLT_ProxyGarbage: VSL_tag_e = 10;
pub const VSL_tag_e_SLT_Length: VSL_tag_e = 11;
pub const VSL_tag_e_SLT_FetchError: VSL_tag_e = 12;
pub const VSL_tag_e_SLT_ReqMethod: VSL_tag_e = 13;
pub const VSL_tag_e_SLT_ReqURL: VSL_tag_e = 14;
pub const VSL_tag_e_SLT_ReqProtocol: VSL_tag_e = 15;
pub const VSL_tag_e_SLT_ReqStatus: VSL_tag_e = 16;
pub const VSL_tag_e_SLT_ReqReason: VSL_tag_e = 17;
pub const VSL_tag_e_SLT_ReqHeader: VSL_tag_e = 18;
pub const VSL_tag_e_SLT_ReqUnset: VSL_tag_e = 19;
pub const VSL_tag_e_SLT_ReqLost: VSL_tag_e = 20;
pub const VSL_tag_e_SLT_RespMethod: VSL_tag_e = 21;
pub const VSL_tag_e_SLT_RespURL: VSL_tag_e = 22;
pub const VSL_tag_e_SLT_RespProtocol: VSL_tag_e = 23;
pub const VSL_tag_e_SLT_RespStatus: VSL_tag_e = 24;
pub const VSL_tag_e_SLT_RespReason: VSL_tag_e = 25;
pub const VSL_tag_e_SLT_RespHeader: VSL_tag_e = 26;
pub const VSL_tag_e_SLT_RespUnset: VSL_tag_e = 27;
pub const VSL_tag_e_SLT_RespLost: VSL_tag_e = 28;
pub const VSL_tag_e_SLT_BereqMethod: VSL_tag_e = 29;
pub const VSL_tag_e_SLT_BereqURL: VSL_tag_e = 30;
pub const VSL_tag_e_SLT_BereqProtocol: VSL_tag_e = 31;
pub const VSL_tag_e_SLT_BereqStatus: VSL_tag_e = 32;
pub const VSL_tag_e_SLT_BereqReason: VSL_tag_e = 33;
pub const VSL_tag_e_SLT_BereqHeader: VSL_tag_e = 34;
pub const VSL_tag_e_SLT_BereqUnset: VSL_tag_e = 35;
pub const VSL_tag_e_SLT_BereqLost: VSL_tag_e = 36;
pub const VSL_tag_e_SLT_BerespMethod: VSL_tag_e = 37;
pub const VSL_tag_e_SLT_BerespURL: VSL_tag_e = 38;
pub const VSL_tag_e_SLT_BerespProtocol: VSL_tag_e = 39;
pub const VSL_tag_e_SLT_BerespStatus: VSL_tag_e = 40;
pub const VSL_tag_e_SLT_BerespReason: VSL_tag_e = 41;
pub const VSL_tag_e_SLT_BerespHeader: VSL_tag_e = 42;
pub const VSL_tag_e_SLT_BerespUnset: VSL_tag_e = 43;
pub const VSL_tag_e_SLT_BerespLost: VSL_tag_e = 44;
pub const VSL_tag_e_SLT_ObjMethod: VSL_tag_e = 45;
pub const VSL_tag_e_SLT_ObjURL: VSL_tag_e = 46;
pub const VSL_tag_e_SLT_ObjProtocol: VSL_tag_e = 47;
pub const VSL_tag_e_SLT_ObjStatus: VSL_tag_e = 48;
pub const VSL_tag_e_SLT_ObjReason: VSL_tag_e = 49;
pub const VSL_tag_e_SLT_ObjHeader: VSL_tag_e = 50;
pub const VSL_tag_e_SLT_ObjUnset: VSL_tag_e = 51;
pub const VSL_tag_e_SLT_ObjLost: VSL_tag_e = 52;
pub const VSL_tag_e_SLT_BogoHeader: VSL_tag_e = 53;
pub const VSL_tag_e_SLT_LostHeader: VSL_tag_e = 54;
pub const VSL_tag_e_SLT_TTL: VSL_tag_e = 55;
pub const VSL_tag_e_SLT_Fetch_Body: VSL_tag_e = 56;
pub const VSL_tag_e_SLT_VCL_acl: VSL_tag_e = 57;
pub const VSL_tag_e_SLT_VCL_call: VSL_tag_e = 58;
pub const VSL_tag_e_SLT_VCL_trace: VSL_tag_e = 59;
pub const VSL_tag_e_SLT_VCL_return: VSL_tag_e = 60;
pub const VSL_tag_e_SLT_ReqStart: VSL_tag_e = 61;
pub const VSL_tag_e_SLT_Hit: VSL_tag_e = 62;
pub const VSL_tag_e_SLT_HitPass: VSL_tag_e = 63;
pub const VSL_tag_e_SLT_ExpBan: VSL_tag_e = 64;
pub const VSL_tag_e_SLT_ExpKill: VSL_tag_e = 65;
pub const VSL_tag_e_SLT_WorkThread: VSL_tag_e = 66;
pub const VSL_tag_e_SLT_ESI_xmlerror: VSL_tag_e = 67;
pub const VSL_tag_e_SLT_Hash: VSL_tag_e = 68;
pub const VSL_tag_e_SLT_Backend_health: VSL_tag_e = 69;
pub const VSL_tag_e_SLT_VCL_Log: VSL_tag_e = 70;
pub const VSL_tag_e_SLT_VCL_Error: VSL_tag_e = 71;
pub const VSL_tag_e_SLT_Gzip: VSL_tag_e = 72;
pub const VSL_tag_e_SLT_Link: VSL_tag_e = 73;
pub const VSL_tag_e_SLT_Begin: VSL_tag_e = 74;
pub const VSL_tag_e_SLT_End: VSL_tag_e = 75;
pub const VSL_tag_e_SLT_VSL: VSL_tag_e = 76;
pub const VSL_tag_e_SLT_Storage: VSL_tag_e = 77;
pub const VSL_tag_e_SLT_Timestamp: VSL_tag_e = 78;
pub const VSL_tag_e_SLT_ReqAcct: VSL_tag_e = 79;
pub const VSL_tag_e_SLT_PipeAcct: VSL_tag_e = 80;
pub const VSL_tag_e_SLT_BereqAcct: VSL_tag_e = 81;
pub const VSL_tag_e_SLT_VfpAcct: VSL_tag_e = 82;
pub const VSL_tag_e_SLT_Witness: VSL_tag_e = 83;
pub const VSL_tag_e_SLT_H2RxHdr: VSL_tag_e = 84;
pub const VSL_tag_e_SLT_H2RxBody: VSL_tag_e = 85;
pub const VSL_tag_e_SLT_H2TxHdr: VSL_tag_e = 86;
pub const VSL_tag_e_SLT_H2TxBody: VSL_tag_e = 87;
pub const VSL_tag_e_SLT_HitMiss: VSL_tag_e = 88;
pub const VSL_tag_e_SLT_Filters: VSL_tag_e = 89;
pub const VSL_tag_e_SLT_SessError: VSL_tag_e = 90;
pub const VSL_tag_e_SLT_VCL_use: VSL_tag_e = 91;
pub const VSL_tag_e_SLT_Notice: VSL_tag_e = 92;
pub const VSL_tag_e_SLT_VdpAcct: VSL_tag_e = 93;
pub const VSL_tag_e_SLT__Reserved: VSL_tag_e = 254;
pub const VSL_tag_e_SLT__Batch: VSL_tag_e = 255;
pub type VSL_tag_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vxids {
    pub vxid: u64,
}
#[test]
fn bindgen_test_layout_vxids() {
    const UNINIT: ::std::mem::MaybeUninit<vxids> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vxids>(),
        8usize,
        concat!("Size of: ", stringify!(vxids))
    );
    assert_eq!(
        ::std::mem::align_of::<vxids>(),
        8usize,
        concat!("Alignment of ", stringify!(vxids))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vxid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vxids),
            "::",
            stringify!(vxid)
        )
    );
}
pub type vxid_t = vxids;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct body_status {
    pub name: *const ::std::os::raw::c_char,
    pub nbr: ::std::os::raw::c_int,
    pub avail: ::std::os::raw::c_int,
    pub length_known: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_body_status() {
    const UNINIT: ::std::mem::MaybeUninit<body_status> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<body_status>(),
        24usize,
        concat!("Size of: ", stringify!(body_status))
    );
    assert_eq!(
        ::std::mem::align_of::<body_status>(),
        8usize,
        concat!("Alignment of ", stringify!(body_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(body_status),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(body_status),
            "::",
            stringify!(nbr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).avail) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(body_status),
            "::",
            stringify!(avail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length_known) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(body_status),
            "::",
            stringify!(length_known)
        )
    );
}
impl Default for body_status {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static BS_NONE: [body_status; 1usize];
}
extern "C" {
    pub static BS_ERROR: [body_status; 1usize];
}
extern "C" {
    pub static BS_CHUNKED: [body_status; 1usize];
}
extern "C" {
    pub static BS_LENGTH: [body_status; 1usize];
}
extern "C" {
    pub static BS_EOF: [body_status; 1usize];
}
extern "C" {
    pub static BS_TAKEN: [body_status; 1usize];
}
extern "C" {
    pub static BS_CACHED: [body_status; 1usize];
}
pub type body_status_t = *const body_status;
pub type hdr_t = *const ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stream_close {
    pub magic: ::std::os::raw::c_uint,
    pub idx: ::std::os::raw::c_int,
    pub is_err: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_stream_close() {
    const UNINIT: ::std::mem::MaybeUninit<stream_close> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stream_close>(),
        32usize,
        concat!("Size of: ", stringify!(stream_close))
    );
    assert_eq!(
        ::std::mem::align_of::<stream_close>(),
        8usize,
        concat!("Alignment of ", stringify!(stream_close))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stream_close),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stream_close),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_err) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stream_close),
            "::",
            stringify!(is_err)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stream_close),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stream_close),
            "::",
            stringify!(desc)
        )
    );
}
impl Default for stream_close {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static SC_NULL: [stream_close; 1usize];
}
extern "C" {
    pub static SC_REM_CLOSE: [stream_close; 1usize];
}
extern "C" {
    pub static SC_REQ_CLOSE: [stream_close; 1usize];
}
extern "C" {
    pub static SC_REQ_HTTP10: [stream_close; 1usize];
}
extern "C" {
    pub static SC_RX_BAD: [stream_close; 1usize];
}
extern "C" {
    pub static SC_RX_BODY: [stream_close; 1usize];
}
extern "C" {
    pub static SC_RX_JUNK: [stream_close; 1usize];
}
extern "C" {
    pub static SC_RX_OVERFLOW: [stream_close; 1usize];
}
extern "C" {
    pub static SC_RX_TIMEOUT: [stream_close; 1usize];
}
extern "C" {
    pub static SC_RX_CLOSE_IDLE: [stream_close; 1usize];
}
extern "C" {
    pub static SC_TX_PIPE: [stream_close; 1usize];
}
extern "C" {
    pub static SC_TX_ERROR: [stream_close; 1usize];
}
extern "C" {
    pub static SC_TX_EOF: [stream_close; 1usize];
}
extern "C" {
    pub static SC_RESP_CLOSE: [stream_close; 1usize];
}
extern "C" {
    pub static SC_OVERLOAD: [stream_close; 1usize];
}
extern "C" {
    pub static SC_PIPE_OVERFLOW: [stream_close; 1usize];
}
extern "C" {
    pub static SC_RANGE_SHORT: [stream_close; 1usize];
}
extern "C" {
    pub static SC_REQ_HTTP20: [stream_close; 1usize];
}
extern "C" {
    pub static SC_VCL_FAILURE: [stream_close; 1usize];
}
extern "C" {
    pub static SC_RAPID_RESET: [stream_close; 1usize];
}
extern "C" {
    pub static SC_BANKRUPT: [stream_close; 1usize];
}
pub const HTTP_HDR_METHOD: _bindgen_ty_15 = 0;
pub const HTTP_HDR_URL: _bindgen_ty_15 = 1;
pub const HTTP_HDR_PROTO: _bindgen_ty_15 = 2;
pub const HTTP_HDR_STATUS: _bindgen_ty_15 = 3;
pub const HTTP_HDR_REASON: _bindgen_ty_15 = 4;
pub const HTTP_HDR_FIRST: _bindgen_ty_15 = 5;
pub const HTTP_HDR_UNSET: _bindgen_ty_15 = 6;
pub const HTTP_HDR_LOST: _bindgen_ty_15 = 7;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ban {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ban_proto {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct listen_sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mempool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objhead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req_step {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct transport {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_lck {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_main_wrk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct worker_priv {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock {
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lock() {
    const UNINIT: ::std::mem::MaybeUninit<lock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lock>(),
        8usize,
        concat!("Size of: ", stringify!(lock))
    );
    assert_eq!(
        ::std::mem::align_of::<lock>(),
        8usize,
        concat!("Alignment of ", stringify!(lock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for lock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ws {
    pub magic: ::std::os::raw::c_uint,
    pub id: [::std::os::raw::c_char; 4usize],
    pub s: *mut ::std::os::raw::c_char,
    pub f: *mut ::std::os::raw::c_char,
    pub r: *mut ::std::os::raw::c_char,
    pub e: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ws() {
    const UNINIT: ::std::mem::MaybeUninit<ws> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ws>(),
        40usize,
        concat!("Size of: ", stringify!(ws))
    );
    assert_eq!(
        ::std::mem::align_of::<ws>(),
        8usize,
        concat!("Alignment of ", stringify!(ws))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(magic))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(e))
    );
}
impl Default for ws {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http {
    pub magic: ::std::os::raw::c_uint,
    pub shd: u16,
    pub hd: *mut txt,
    pub hdf: *mut ::std::os::raw::c_uchar,
    pub nhd: u16,
    pub logtag: VSL_tag_e,
    pub vsl: *mut vsl_log,
    pub ws: *mut ws,
    pub status: u16,
    pub protover: u8,
}
#[test]
fn bindgen_test_layout_http() {
    const UNINIT: ::std::mem::MaybeUninit<http> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<http>(),
        56usize,
        concat!("Size of: ", stringify!(http))
    );
    assert_eq!(
        ::std::mem::align_of::<http>(),
        8usize,
        concat!("Alignment of ", stringify!(http))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shd) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(shd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hd) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(hd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdf) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(hdf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nhd) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(nhd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logtag) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(logtag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(vsl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(ws))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protover) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(protover)
        )
    );
}
impl Default for http {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acct_req {
    pub req_hdrbytes: u64,
    pub req_bodybytes: u64,
    pub resp_hdrbytes: u64,
    pub resp_bodybytes: u64,
}
#[test]
fn bindgen_test_layout_acct_req() {
    const UNINIT: ::std::mem::MaybeUninit<acct_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<acct_req>(),
        32usize,
        concat!("Size of: ", stringify!(acct_req))
    );
    assert_eq!(
        ::std::mem::align_of::<acct_req>(),
        8usize,
        concat!("Alignment of ", stringify!(acct_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_hdrbytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(req_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_bodybytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(req_bodybytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_hdrbytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(resp_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_bodybytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(resp_bodybytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acct_bereq {
    pub bereq_hdrbytes: u64,
    pub bereq_bodybytes: u64,
    pub beresp_hdrbytes: u64,
    pub beresp_bodybytes: u64,
}
#[test]
fn bindgen_test_layout_acct_bereq() {
    const UNINIT: ::std::mem::MaybeUninit<acct_bereq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<acct_bereq>(),
        32usize,
        concat!("Size of: ", stringify!(acct_bereq))
    );
    assert_eq!(
        ::std::mem::align_of::<acct_bereq>(),
        8usize,
        concat!("Alignment of ", stringify!(acct_bereq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq_hdrbytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(bereq_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq_bodybytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(bereq_bodybytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beresp_hdrbytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(beresp_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beresp_bodybytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(beresp_bodybytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_log {
    pub wlb: *mut u32,
    pub wlp: *mut u32,
    pub wle: *mut u32,
    pub wlr: ::std::os::raw::c_uint,
    pub wid: vxid_t,
}
#[test]
fn bindgen_test_layout_vsl_log() {
    const UNINIT: ::std::mem::MaybeUninit<vsl_log> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vsl_log>(),
        40usize,
        concat!("Size of: ", stringify!(vsl_log))
    );
    assert_eq!(
        ::std::mem::align_of::<vsl_log>(),
        8usize,
        concat!("Alignment of ", stringify!(vsl_log))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wlb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wlb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wlp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wlp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wlr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wlr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wid)
        )
    );
}
impl Default for vsl_log {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_privs {
    pub rbh_root: *mut vrt_priv,
}
#[test]
fn bindgen_test_layout_vrt_privs() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_privs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_privs>(),
        8usize,
        concat!("Size of: ", stringify!(vrt_privs))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_privs>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_privs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbh_root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_privs),
            "::",
            stringify!(rbh_root)
        )
    );
}
impl Default for vrt_privs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type task_func_t = ::std::option::Option<
    unsafe extern "C" fn(wrk: *mut worker, priv_: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool_task {
    pub list: pool_task__bindgen_ty_1,
    pub func: task_func_t,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool_task__bindgen_ty_1 {
    pub vtqe_next: *mut pool_task,
    pub vtqe_prev: *mut *mut pool_task,
}
#[test]
fn bindgen_test_layout_pool_task__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pool_task__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pool_task__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(pool_task__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pool_task__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pool_task__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for pool_task__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_pool_task() {
    const UNINIT: ::std::mem::MaybeUninit<pool_task> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pool_task>(),
        32usize,
        concat!("Size of: ", stringify!(pool_task))
    );
    assert_eq!(
        ::std::mem::align_of::<pool_task>(),
        8usize,
        concat!("Alignment of ", stringify!(pool_task))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for pool_task {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const task_prio_TASK_QUEUE_BO: task_prio = 0;
pub const task_prio_TASK_QUEUE_RUSH: task_prio = 1;
pub const task_prio_TASK_QUEUE_REQ: task_prio = 2;
pub const task_prio_TASK_QUEUE_STR: task_prio = 3;
pub const task_prio_TASK_QUEUE_VCA: task_prio = 4;
pub const task_prio_TASK_QUEUE_BG: task_prio = 5;
pub const task_prio_TASK_QUEUE__END: task_prio = 6;
pub type task_prio = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct worker {
    pub magic: ::std::os::raw::c_uint,
    pub strangelove: ::std::os::raw::c_int,
    pub wpriv: *mut worker_priv,
    pub pool: *mut pool,
    pub stats: *mut VSC_main_wrk,
    pub vsl: *mut vsl_log,
    pub task: [pool_task; 1usize],
    pub lastused: vtim_real,
    pub v1l: *mut v1l,
    pub cond: pthread_cond_t,
    pub aws: [ws; 1usize],
    pub cur_method: ::std::os::raw::c_uint,
    pub seen_methods: ::std::os::raw::c_uint,
    pub vpi: *mut wrk_vpi,
}
#[test]
fn bindgen_test_layout_worker() {
    const UNINIT: ::std::mem::MaybeUninit<worker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<worker>(),
        192usize,
        concat!("Size of: ", stringify!(worker))
    );
    assert_eq!(
        ::std::mem::align_of::<worker>(),
        8usize,
        concat!("Alignment of ", stringify!(worker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strangelove) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(strangelove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wpriv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(wpriv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stats) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastused) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(lastused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v1l) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(v1l)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aws) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(aws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_method) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(cur_method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seen_methods) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(seen_methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vpi) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(vpi)
        )
    );
}
impl Default for worker {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct storeobj {
    pub stevedore: *const stevedore,
    pub priv_: *mut ::std::os::raw::c_void,
    pub priv2: u64,
}
#[test]
fn bindgen_test_layout_storeobj() {
    const UNINIT: ::std::mem::MaybeUninit<storeobj> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<storeobj>(),
        24usize,
        concat!("Size of: ", stringify!(storeobj))
    );
    assert_eq!(
        ::std::mem::align_of::<storeobj>(),
        8usize,
        concat!("Alignment of ", stringify!(storeobj))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stevedore) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(storeobj),
            "::",
            stringify!(stevedore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(storeobj),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(storeobj),
            "::",
            stringify!(priv2)
        )
    );
}
impl Default for storeobj {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const boc_state_e_BOS_INVALID: boc_state_e = 0;
pub const boc_state_e_BOS_REQ_DONE: boc_state_e = 1;
pub const boc_state_e_BOS_PREP_STREAM: boc_state_e = 2;
pub const boc_state_e_BOS_STREAM: boc_state_e = 3;
pub const boc_state_e_BOS_FINISHED: boc_state_e = 4;
pub const boc_state_e_BOS_FAILED: boc_state_e = 5;
pub type boc_state_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct boc {
    pub magic: ::std::os::raw::c_uint,
    pub refcount: ::std::os::raw::c_uint,
    pub mtx: lock,
    pub cond: pthread_cond_t,
    pub stevedore_priv: *mut ::std::os::raw::c_void,
    pub state: boc_state_e,
    pub vary: *mut u8,
    pub fetched_so_far: u64,
    pub delivered_so_far: u64,
    pub transit_buffer: u64,
}
#[test]
fn bindgen_test_layout_boc() {
    const UNINIT: ::std::mem::MaybeUninit<boc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<boc>(),
        112usize,
        concat!("Size of: ", stringify!(boc))
    );
    assert_eq!(
        ::std::mem::align_of::<boc>(),
        8usize,
        concat!("Alignment of ", stringify!(boc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtx) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(boc), "::", stringify!(mtx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(boc), "::", stringify!(cond))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stevedore_priv) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(stevedore_priv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vary) as usize - ptr as usize },
        80usize,
        concat!("Offset of field: ", stringify!(boc), "::", stringify!(vary))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fetched_so_far) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(fetched_so_far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delivered_so_far) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(delivered_so_far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transit_buffer) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(transit_buffer)
        )
    );
}
impl Default for boc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const obj_attr_OA_LEN: obj_attr = 0;
pub const obj_attr_OA_VXID: obj_attr = 1;
pub const obj_attr_OA_FLAGS: obj_attr = 2;
pub const obj_attr_OA_GZIPBITS: obj_attr = 3;
pub const obj_attr_OA_LASTMODIFIED: obj_attr = 4;
pub const obj_attr_OA_VARY: obj_attr = 5;
pub const obj_attr_OA_HEADERS: obj_attr = 6;
pub const obj_attr_OA_ESIDATA: obj_attr = 7;
pub const obj_attr_OA__MAX: obj_attr = 8;
pub type obj_attr = ::std::os::raw::c_uint;
pub const obj_flags_OF_GZIPED: obj_flags = 2;
pub const obj_flags_OF_CHGCE: obj_flags = 4;
pub const obj_flags_OF_IMSCAND: obj_flags = 8;
pub const obj_flags_OF_ESIPROC: obj_flags = 16;
pub type obj_flags = ::std::os::raw::c_uint;
pub const oc_flags_OC_F_BUSY: oc_flags = 2;
pub const oc_flags_OC_F_HFM: oc_flags = 4;
pub const oc_flags_OC_F_HFP: oc_flags = 8;
pub const oc_flags_OC_F_CANCEL: oc_flags = 16;
pub const oc_flags_OC_F_PRIVATE: oc_flags = 32;
pub const oc_flags_OC_F_FAILED: oc_flags = 64;
pub const oc_flags_OC_F_DYING: oc_flags = 128;
pub type oc_flags = ::std::os::raw::c_uint;
pub const oc_exp_flags_OC_EF_POSTED: oc_exp_flags = 2;
pub const oc_exp_flags_OC_EF_REFD: oc_exp_flags = 4;
pub const oc_exp_flags_OC_EF_MOVE: oc_exp_flags = 8;
pub const oc_exp_flags_OC_EF_INSERT: oc_exp_flags = 16;
pub const oc_exp_flags_OC_EF_REMOVE: oc_exp_flags = 32;
pub const oc_exp_flags_OC_EF_NEW: oc_exp_flags = 64;
pub type oc_exp_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore {
    pub magic: ::std::os::raw::c_uint,
    pub refcnt: ::std::os::raw::c_int,
    pub stobj: [storeobj; 1usize],
    pub objhead: *mut objhead,
    pub boc: *mut boc,
    pub timer_when: vtim_real,
    pub hits: VCL_INT,
    pub t_origin: vtim_real,
    pub ttl: f32,
    pub grace: f32,
    pub keep: f32,
    pub flags: u8,
    pub exp_flags: u8,
    pub oa_present: u16,
    pub timer_idx: ::std::os::raw::c_uint,
    pub last_lru: vtim_real,
    pub hsh_list: objcore__bindgen_ty_1,
    pub lru_list: objcore__bindgen_ty_2,
    pub ban_list: objcore__bindgen_ty_3,
    pub exp_list: objcore__bindgen_ty_4,
    pub ban: *mut ban,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_1 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<objcore__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for objcore__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_2 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<objcore__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_2),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_2),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for objcore__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_3 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<objcore__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_3),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_3),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for objcore__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_4 {
    pub vstqe_next: *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<objcore__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vstqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_4),
            "::",
            stringify!(vstqe_next)
        )
    );
}
impl Default for objcore__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_objcore() {
    const UNINIT: ::std::mem::MaybeUninit<objcore> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore>(),
        168usize,
        concat!("Size of: ", stringify!(objcore))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stobj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(stobj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objhead) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(objhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(boc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_when) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(timer_when)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hits) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_origin) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(t_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grace) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(grace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(keep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exp_flags) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(exp_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oa_present) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(oa_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_idx) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(timer_idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_lru) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(last_lru)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hsh_list) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(hsh_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lru_list) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(lru_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ban_list) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(ban_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exp_list) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(exp_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ban) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(ban)
        )
    );
}
impl Default for objcore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const director_state_e_DIR_S_NULL: director_state_e = 0;
pub const director_state_e_DIR_S_HDRS: director_state_e = 1;
pub const director_state_e_DIR_S_BODY: director_state_e = 2;
pub type director_state_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct busyobj {
    pub magic: ::std::os::raw::c_uint,
    pub end: *mut ::std::os::raw::c_char,
    pub retries: ::std::os::raw::c_uint,
    pub req: *mut req,
    pub sp: *mut sess,
    pub wrk: *mut worker,
    pub vfc: *mut vfp_ctx,
    pub vfp_filter_list: *const ::std::os::raw::c_char,
    pub ws: [ws; 1usize],
    pub ws_bo: usize,
    pub bereq0: *mut http,
    pub bereq: *mut http,
    pub beresp: *mut http,
    pub bereq_body: *mut objcore,
    pub stale_oc: *mut objcore,
    pub fetch_objcore: *mut objcore,
    pub no_retry: *const ::std::os::raw::c_char,
    pub htc: *mut http_conn,
    pub fetch_task: [pool_task; 1usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub connect_timeout: vtim_dur,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
    pub task_deadline: vtim_dur,
    pub t_first: vtim_real,
    pub t_resp: vtim_real,
    pub t_prev: vtim_real,
    pub acct: acct_bereq,
    pub storage: *const stevedore,
    pub director_req: *const director,
    pub director_resp: *const director,
    pub director_state: director_state_e,
    pub vcl: *mut vcl,
    pub vsl: [vsl_log; 1usize],
    pub digest: [u8; 32usize],
    pub privs: [vrt_privs; 1usize],
    pub err_code: u16,
    pub err_reason: *const ::std::os::raw::c_char,
    pub client_identity: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_busyobj() {
    const UNINIT: ::std::mem::MaybeUninit<busyobj> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<busyobj>(),
        448usize,
        concat!("Size of: ", stringify!(busyobj))
    );
    assert_eq!(
        ::std::mem::align_of::<busyobj>(),
        8usize,
        concat!("Alignment of ", stringify!(busyobj))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retries) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(retries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrk) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(wrk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vfc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfp_filter_list) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vfp_filter_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(ws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws_bo) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(ws_bo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq0) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(bereq0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(bereq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beresp) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(beresp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq_body) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(bereq_body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stale_oc) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(stale_oc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fetch_objcore) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(fetch_objcore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_retry) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(no_retry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htc) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(htc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fetch_task) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(fetch_task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_timeout) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(connect_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_byte_timeout) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(first_byte_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).between_bytes_timeout) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(between_bytes_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task_deadline) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(task_deadline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_first) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(t_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_resp) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(t_resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_prev) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(t_prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acct) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(acct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).director_req) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(director_req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).director_resp) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(director_resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).director_state) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(director_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).privs) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(privs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_code) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_reason) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(err_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_identity) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(client_identity)
        )
    );
}
impl Default for busyobj {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl busyobj {
    #[inline]
    pub fn uncacheable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uncacheable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_bgfetch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_bgfetch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitmiss(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitmiss(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitpass(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitpass(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trace(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trace(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_esi(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_esi(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_gzip(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_gzip(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_gunzip(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_gunzip(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_stream(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_stream(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn was_304(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_was_304(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uncacheable: ::std::os::raw::c_uint,
        is_bgfetch: ::std::os::raw::c_uint,
        is_hitmiss: ::std::os::raw::c_uint,
        is_hitpass: ::std::os::raw::c_uint,
        trace: ::std::os::raw::c_uint,
        do_esi: ::std::os::raw::c_uint,
        do_gzip: ::std::os::raw::c_uint,
        do_gunzip: ::std::os::raw::c_uint,
        do_stream: ::std::os::raw::c_uint,
        was_304: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let uncacheable: u32 = unsafe { ::std::mem::transmute(uncacheable) };
            uncacheable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_bgfetch: u32 = unsafe { ::std::mem::transmute(is_bgfetch) };
            is_bgfetch as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_hitmiss: u32 = unsafe { ::std::mem::transmute(is_hitmiss) };
            is_hitmiss as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_hitpass: u32 = unsafe { ::std::mem::transmute(is_hitpass) };
            is_hitpass as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let trace: u32 = unsafe { ::std::mem::transmute(trace) };
            trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let do_esi: u32 = unsafe { ::std::mem::transmute(do_esi) };
            do_esi as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let do_gzip: u32 = unsafe { ::std::mem::transmute(do_gzip) };
            do_gzip as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let do_gunzip: u32 = unsafe { ::std::mem::transmute(do_gunzip) };
            do_gunzip as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let do_stream: u32 = unsafe { ::std::mem::transmute(do_stream) };
            do_stream as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let was_304: u32 = unsafe { ::std::mem::transmute(was_304) };
            was_304 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reqtop {
    pub magic: ::std::os::raw::c_uint,
    pub topreq: *mut req,
    pub vcl0: *mut vcl,
    pub privs: [vrt_privs; 1usize],
}
#[test]
fn bindgen_test_layout_reqtop() {
    const UNINIT: ::std::mem::MaybeUninit<reqtop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<reqtop>(),
        32usize,
        concat!("Size of: ", stringify!(reqtop))
    );
    assert_eq!(
        ::std::mem::align_of::<reqtop>(),
        8usize,
        concat!("Alignment of ", stringify!(reqtop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reqtop),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topreq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(reqtop),
            "::",
            stringify!(topreq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl0) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(reqtop),
            "::",
            stringify!(vcl0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).privs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(reqtop),
            "::",
            stringify!(privs)
        )
    );
}
impl Default for reqtop {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req {
    pub magic: ::std::os::raw::c_uint,
    pub req_body_status: body_status_t,
    pub doclose: stream_close_t,
    pub restarts: ::std::os::raw::c_uint,
    pub esi_level: ::std::os::raw::c_uint,
    pub res_mode: ::std::os::raw::c_uint,
    pub req_step: *const req_step,
    pub top: *mut reqtop,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub err_code: u16,
    pub err_reason: *const ::std::os::raw::c_char,
    pub sp: *mut sess,
    pub wrk: *mut worker,
    pub task: [pool_task; 1usize],
    pub transport: *const transport,
    pub transport_priv: *mut ::std::os::raw::c_void,
    pub w_list: req__bindgen_ty_1,
    pub body_oc: *mut objcore,
    pub hash_objhead: *mut objhead,
    pub vary_b: *mut u8,
    pub vary_e: *mut u8,
    pub digest: [u8; 32usize],
    pub d_ttl: vtim_dur,
    pub d_grace: vtim_dur,
    pub storage: *const stevedore,
    pub director_hint: *const director,
    pub vcl: *mut vcl,
    pub ws_req: usize,
    pub t_first: vtim_real,
    pub t_prev: vtim_real,
    pub t_req: vtim_real,
    pub t_resp: vtim_real,
    pub htc: *mut http_conn,
    pub vfc: *mut vfp_ctx,
    pub client_identity: *const ::std::os::raw::c_char,
    pub http: *mut http,
    pub http0: *mut http,
    pub resp: *mut http,
    pub resp_len: intmax_t,
    pub ws: [ws; 1usize],
    pub objcore: *mut objcore,
    pub stale_oc: *mut objcore,
    pub vdc: *mut vdp_ctx,
    pub vdp_filter_list: *const ::std::os::raw::c_char,
    pub vsl: [vsl_log; 1usize],
    pub acct: acct_req,
    pub privs: [vrt_privs; 1usize],
    pub vcf: *mut vcf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req__bindgen_ty_1 {
    pub vtqe_next: *mut req,
    pub vtqe_prev: *mut *mut req,
}
#[test]
fn bindgen_test_layout_req__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<req__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<req__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(req__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<req__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(req__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(req__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(req__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for req__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_req() {
    const UNINIT: ::std::mem::MaybeUninit<req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<req>(),
        512usize,
        concat!("Size of: ", stringify!(req))
    );
    assert_eq!(
        ::std::mem::align_of::<req>(),
        8usize,
        concat!("Alignment of ", stringify!(req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_body_status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(req_body_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doclose) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(doclose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).restarts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(restarts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esi_level) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(esi_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res_mode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(res_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_step) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(req_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(top))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_code) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_reason) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(err_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        72usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(sp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrk) as usize - ptr as usize },
        80usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(wrk))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task) as usize - ptr as usize },
        88usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(task))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport_priv) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(transport_priv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_list) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(w_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_oc) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(body_oc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash_objhead) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(hash_objhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vary_b) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(vary_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vary_e) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(vary_e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_ttl) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(d_ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_grace) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(d_grace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).director_hint) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(director_hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl) as usize - ptr as usize },
        248usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vcl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws_req) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(ws_req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_first) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_prev) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_req) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_resp) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htc) as usize - ptr as usize },
        296usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(htc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc) as usize - ptr as usize },
        304usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vfc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_identity) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(client_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http) as usize - ptr as usize },
        320usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(http))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http0) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(http0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp) as usize - ptr as usize },
        336usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(resp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_len) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(resp_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        352usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(ws))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objcore) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(objcore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stale_oc) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(stale_oc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdc) as usize - ptr as usize },
        408usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vdc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdp_filter_list) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(vdp_filter_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        424usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vsl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acct) as usize - ptr as usize },
        464usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(acct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).privs) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(privs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcf) as usize - ptr as usize },
        504usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vcf))
    );
}
impl Default for req {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl req {
    #[inline]
    pub fn disable_esi(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_esi(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_ignore_busy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_ignore_busy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_ignore_vary(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_ignore_vary(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_always_miss(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_always_miss(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waitinglist(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waitinglist(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want100cont(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want100cont(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn late100cont(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_late100cont(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn req_reset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_req_reset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitmiss(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitmiss(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitpass(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitpass(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trace(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trace(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_esi: ::std::os::raw::c_uint,
        hash_ignore_busy: ::std::os::raw::c_uint,
        hash_ignore_vary: ::std::os::raw::c_uint,
        hash_always_miss: ::std::os::raw::c_uint,
        is_hit: ::std::os::raw::c_uint,
        waitinglist: ::std::os::raw::c_uint,
        want100cont: ::std::os::raw::c_uint,
        late100cont: ::std::os::raw::c_uint,
        req_reset: ::std::os::raw::c_uint,
        is_hitmiss: ::std::os::raw::c_uint,
        is_hitpass: ::std::os::raw::c_uint,
        trace: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_esi: u32 = unsafe { ::std::mem::transmute(disable_esi) };
            disable_esi as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hash_ignore_busy: u32 = unsafe { ::std::mem::transmute(hash_ignore_busy) };
            hash_ignore_busy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hash_ignore_vary: u32 = unsafe { ::std::mem::transmute(hash_ignore_vary) };
            hash_ignore_vary as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hash_always_miss: u32 = unsafe { ::std::mem::transmute(hash_always_miss) };
            hash_always_miss as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_hit: u32 = unsafe { ::std::mem::transmute(is_hit) };
            is_hit as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let waitinglist: u32 = unsafe { ::std::mem::transmute(waitinglist) };
            waitinglist as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let want100cont: u32 = unsafe { ::std::mem::transmute(want100cont) };
            want100cont as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let late100cont: u32 = unsafe { ::std::mem::transmute(late100cont) };
            late100cont as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let req_reset: u32 = unsafe { ::std::mem::transmute(req_reset) };
            req_reset as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_hitmiss: u32 = unsafe { ::std::mem::transmute(is_hitmiss) };
            is_hitmiss as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_hitpass: u32 = unsafe { ::std::mem::transmute(is_hitpass) };
            is_hitpass as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let trace: u32 = unsafe { ::std::mem::transmute(trace) };
            trace as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const sess_attr_SA_TRANSPORT: sess_attr = 0;
pub const sess_attr_SA_REMOTE_ADDR: sess_attr = 1;
pub const sess_attr_SA_LOCAL_ADDR: sess_attr = 2;
pub const sess_attr_SA_CLIENT_ADDR: sess_attr = 3;
pub const sess_attr_SA_SERVER_ADDR: sess_attr = 4;
pub const sess_attr_SA_CLIENT_IP: sess_attr = 5;
pub const sess_attr_SA_CLIENT_PORT: sess_attr = 6;
pub const sess_attr_SA_PROXY_TLV: sess_attr = 7;
pub const sess_attr_SA_PROTO_PRIV: sess_attr = 8;
pub const sess_attr_SA_LAST: sess_attr = 9;
pub type sess_attr = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sess {
    pub magic: ::std::os::raw::c_uint,
    pub sattr: [u16; 9usize],
    pub listen_sock: *mut listen_sock,
    pub refcnt: ::std::os::raw::c_int,
    pub fd: ::std::os::raw::c_int,
    pub vxid: vxid_t,
    pub mtx: lock,
    pub pool: *mut pool,
    pub ws: [ws; 1usize],
    pub t_open: vtim_real,
    pub t_idle: vtim_real,
    pub timeout_idle: vtim_dur,
    pub timeout_linger: vtim_dur,
    pub send_timeout: vtim_dur,
    pub idle_send_timeout: vtim_dur,
}
#[test]
fn bindgen_test_layout_sess() {
    const UNINIT: ::std::mem::MaybeUninit<sess> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sess>(),
        152usize,
        concat!("Size of: ", stringify!(sess))
    );
    assert_eq!(
        ::std::mem::align_of::<sess>(),
        8usize,
        concat!("Alignment of ", stringify!(sess))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sattr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(sattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listen_sock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(listen_sock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        36usize,
        concat!("Offset of field: ", stringify!(sess), "::", stringify!(fd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vxid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(vxid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtx) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(sess), "::", stringify!(mtx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(sess), "::", stringify!(ws))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_open) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(t_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_idle) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(t_idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_idle) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(timeout_idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_linger) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(timeout_linger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_timeout) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(send_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idle_send_timeout) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(idle_send_timeout)
        )
    );
}
impl Default for sess {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn BAN_Build() -> *mut ban_proto;
}
extern "C" {
    pub fn BAN_AddTest(
        arg1: *mut ban_proto,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BAN_Commit(b: *mut ban_proto) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BAN_Abandon(b: *mut ban_proto);
}
extern "C" {
    pub static mut cli_thread: pthread_t;
}
extern "C" {
    pub fn HTTP_estimate(nhttp: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn HTTP_Clone(to: *mut http, fm: *const http);
}
extern "C" {
    pub fn HTTP_Dup(to: *mut http, fm: *const http);
}
extern "C" {
    pub fn HTTP_create(
        p: *mut ::std::os::raw::c_void,
        nhttp: u16,
        arg1: ::std::os::raw::c_uint,
    ) -> *mut http;
}
extern "C" {
    pub fn http_Status2Reason(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_IsHdr(hh: *const txt, hdr: hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_EstimateWS(fm: *const http, how: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn http_PutResponse(
        to: *mut http,
        proto: *const ::std::os::raw::c_char,
        status: u16,
        response: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn http_FilterReq(to: *mut http, fm: *const http, how: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn HTTP_Encode(
        fm: *const http,
        arg1: *mut u8,
        len: ::std::os::raw::c_uint,
        how: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn HTTP_Decode(to: *mut http, fm: *const u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_ForceHeader(to: *mut http, arg1: hdr_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_AppendHeader(to: *mut http, arg1: hdr_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_PrintfHeader(to: *mut http, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn http_TimeHeader(to: *mut http, fmt: *const ::std::os::raw::c_char, now: vtim_real);
}
extern "C" {
    pub fn http_ViaHeader() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_Proto(to: *mut http);
}
extern "C" {
    pub fn http_SetHeader(to: *mut http, header: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_SetH(
        to: *mut http,
        n: ::std::os::raw::c_uint,
        header: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn http_ForceField(
        to: *mut http,
        n: ::std::os::raw::c_uint,
        t: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn HTTP_Setup(arg1: *mut http, arg2: *mut ws, arg3: *mut vsl_log, arg4: VSL_tag_e);
}
extern "C" {
    pub fn http_Teardown(ht: *mut http);
}
extern "C" {
    pub fn http_GetHdr(
        hp: *const http,
        arg1: hdr_t,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_GetHdrToken(
        hp: *const http,
        arg1: hdr_t,
        token: *const ::std::os::raw::c_char,
        pb: *mut *const ::std::os::raw::c_char,
        pe: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_GetHdrField(
        hp: *const http,
        arg1: hdr_t,
        field: *const ::std::os::raw::c_char,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_GetHdrQ(hp: *const http, arg1: hdr_t, field: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn http_GetContentLength(hp: *const http) -> isize;
}
extern "C" {
    pub fn http_GetContentRange(hp: *const http, lo: *mut isize, hi: *mut isize) -> isize;
}
extern "C" {
    pub fn http_GetRange(
        hp: *const http,
        lo: *mut isize,
        hi: *mut isize,
        len: isize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_GetStatus(hp: *const http) -> u16;
}
extern "C" {
    pub fn http_IsStatus(hp: *const http, arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_SetStatus(to: *mut http, status: u16, reason: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_GetMethod(hp: *const http) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_HdrIs(
        hp: *const http,
        arg1: hdr_t,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_CopyHome(hp: *const http);
}
extern "C" {
    pub fn http_Unset(hp: *mut http, arg1: hdr_t);
}
extern "C" {
    pub fn http_CountHdr(hp: *const http, arg1: hdr_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn http_CollectHdr(hp: *mut http, arg1: hdr_t);
}
extern "C" {
    pub fn http_CollectHdrSep(hp: *mut http, arg1: hdr_t, sep: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_VSL_log(hp: *const http);
}
extern "C" {
    pub fn HTTP_Merge(arg1: *mut worker, arg2: *mut objcore, to: *mut http);
}
extern "C" {
    pub fn HTTP_GetStatusPack(arg1: *mut worker, oc: *mut objcore) -> u16;
}
extern "C" {
    pub fn HTTP_IterHdrPack(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HTTP_GetHdrPack(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: hdr_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_DoConnection(hp: *mut http, sc_close: stream_close_t) -> stream_close_t;
}
extern "C" {
    pub fn http_IsFiltered(
        hp: *const http,
        u: ::std::os::raw::c_uint,
        how: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut H_Accept: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Charset: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Encoding: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Language: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Ranges: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Age: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Allow: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Authorization: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Cache_Control: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Connection: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Encoding: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Language: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Length: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Location: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_MD5: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Range: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Type: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Cookie: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Date: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_ETag: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Expect: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Expires: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_From: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Host: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_HTTP2_Settings: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Match: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Modified_Since: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_None_Match: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Range: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Unmodified_Since: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Keep_Alive: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Last_Modified: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Location: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Max_Forwards: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Pragma: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Proxy_Authenticate: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Proxy_Authorization: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Range: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Referer: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Retry_After: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Server: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Set_Cookie: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_TE: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Trailer: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Transfer_Encoding: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Upgrade: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_User_Agent: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Vary: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Via: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Warning: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_WWW_Authenticate: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_X_Forwarded_For: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static H__Status: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static H__Proto: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static H__Reason: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn Lck__Lock(lck: *mut lock, p: *const ::std::os::raw::c_char, l: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Lck__Unlock(lck: *mut lock, p: *const ::std::os::raw::c_char, l: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Lck__Trylock(
        lck: *mut lock,
        p: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck__New(lck: *mut lock, arg1: *mut VSC_lck, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn Lck__Held(lck: *const lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck__Owned(lck: *const lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut mtxattr_errorcheck: pthread_mutexattr_t;
}
extern "C" {
    pub fn Lck_Delete(lck: *mut lock);
}
extern "C" {
    pub fn Lck_CondWaitUntil(
        arg1: *mut pthread_cond_t,
        arg2: *mut lock,
        when: vtim_real,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck_CondWait(arg1: *mut pthread_cond_t, arg2: *mut lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck_CondWaitTimeout(
        arg1: *mut pthread_cond_t,
        arg2: *mut lock,
        timeout: vtim_dur,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck_CreateClass(
        arg1: *mut *mut vsc_seg,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut VSC_lck;
}
extern "C" {
    pub fn Lck_DestroyClass(arg1: *mut *mut vsc_seg);
}
extern "C" {
    pub static mut lck_ban: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_busyobj: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_cli: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_director: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_exp: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_hcb: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_lru: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_mempool: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_objhdr: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_perpool: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_pipestat: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_probe: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_sess: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_conn_pool: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vbe: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vcapace: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vcl: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vxid: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_waiter: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_wq: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_wstat: *mut VSC_lck;
}
extern "C" {
    pub fn ObjHasAttr(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetAttr(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        len: *mut isize,
    ) -> *const ::std::os::raw::c_void;
}
pub type objiterate_f = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        flush: ::std::os::raw::c_uint,
        ptr: *const ::std::os::raw::c_void,
        len: isize,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ObjIterate(
        arg1: *mut worker,
        arg2: *mut objcore,
        priv_: *mut ::std::os::raw::c_void,
        func: objiterate_f,
        final_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetXID(arg1: *mut worker, arg2: *mut objcore) -> vxid_t;
}
extern "C" {
    pub fn ObjGetLen(arg1: *mut worker, arg2: *mut objcore) -> u64;
}
extern "C" {
    pub fn ObjGetDouble(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetU64(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjCheckFlag(
        arg1: *mut worker,
        arg2: *mut objcore,
        of: obj_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRB_Iterate(
        arg1: *mut worker,
        arg2: *mut vsl_log,
        arg3: *mut req,
        func: objiterate_f,
        priv_: *mut ::std::os::raw::c_void,
    ) -> isize;
}
extern "C" {
    pub fn SES_Get_transport(
        sp: *const sess,
        dst: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_remote_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_local_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_client_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_server_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_client_ip(
        sp: *const sess,
        dst: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_client_port(
        sp: *const sess,
        dst: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_proxy_tlv(sp: *const sess, dst: *mut *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_proto_priv(sp: *const sess, dst: *mut *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_String_Attr(sp: *const sess, a: sess_attr) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VSLv(
        tag: VSL_tag_e,
        vxid: vxid_t,
        fmt: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn VSL(tag: VSL_tag_e, vxid: vxid_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VSLs(tag: VSL_tag_e, vxid: vxid_t, s: *const strands);
}
extern "C" {
    pub fn VSLbv(
        arg1: *mut vsl_log,
        tag: VSL_tag_e,
        fmt: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn VSLb(arg1: *mut vsl_log, tag: VSL_tag_e, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VSLbt(arg1: *mut vsl_log, tag: VSL_tag_e, t: txt);
}
extern "C" {
    pub fn VSLbs(arg1: *mut vsl_log, tag: VSL_tag_e, s: *const strands);
}
extern "C" {
    pub fn VSLb_ts(
        arg1: *mut vsl_log,
        event: *const ::std::os::raw::c_char,
        first: vtim_real,
        pprev: *mut vtim_real,
        now: vtim_real,
    );
}
extern "C" {
    pub fn VSLb_bin(
        arg1: *mut vsl_log,
        arg2: VSL_tag_e,
        arg3: isize,
        arg4: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn VSL_tag_is_masked(tag: VSL_tag_e) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VCL_Name(arg1: *const vcl) -> *const ::std::os::raw::c_char;
}
pub type bgthread_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut worker,
        priv_: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn WRK_BgThread(
        thr: *mut pthread_t,
        name: *const ::std::os::raw::c_char,
        func: bgthread_t,
        priv_: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn WS_Init(
        ws: *mut ws,
        id: *const ::std::os::raw::c_char,
        space: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn WS_ReserveSize(arg1: *mut ws, arg2: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_ReserveAll(arg1: *mut ws) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_Release(ws: *mut ws, bytes: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn WS_ReleaseP(ws: *mut ws, ptr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn WS_Assert(ws: *const ws);
}
extern "C" {
    pub fn WS_Reset(ws: *mut ws, arg1: usize);
}
extern "C" {
    pub fn WS_Alloc(ws: *mut ws, bytes: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn WS_Copy(
        ws: *mut ws,
        str_: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn WS_Snapshot(ws: *mut ws) -> usize;
}
extern "C" {
    pub fn WS_Allocated(
        ws: *const ws,
        ptr: *const ::std::os::raw::c_void,
        len: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WS_Dump(
        ws: *const ws,
        arg1: ::std::os::raw::c_char,
        off: usize,
        buf: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_MarkOverflow(ws: *mut ws);
}
extern "C" {
    pub fn WS_Overflowed(ws: *const ws) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WS_Printf(
        ws: *mut ws,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn WS_VSB_new(arg1: *mut vsb, arg2: *mut ws);
}
extern "C" {
    pub fn WS_VSB_finish(
        arg1: *mut vsb,
        arg2: *mut ws,
        arg3: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn RFC2616_Ttl(
        arg1: *mut busyobj,
        now: vtim_real,
        t_origin: *mut vtim_real,
        ttl: *mut f32,
        grace: *mut f32,
        keep: *mut f32,
    );
}
extern "C" {
    pub fn RFC2616_Req_Gzip(arg1: *const http) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn RFC2616_Do_Cond(sp: *const req) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RFC2616_Weaken_Etag(hp: *mut http);
}
extern "C" {
    pub fn RFC2616_Vary_AE(hp: *mut http);
}
extern "C" {
    pub fn RFC2616_Strong_LM(
        hp: *const http,
        wrk: *mut worker,
        oc: *mut objcore,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcldir {
    pub magic: ::std::os::raw::c_uint,
    pub refcnt: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
    pub dlck: lock,
    pub dir: *mut director,
    pub vcl: *mut vcl,
    pub methods: *const vdi_methods,
    pub list: vcldir__bindgen_ty_1,
    pub admin_health: *mut vdi_ahealth,
    pub health_changed: vtim_real,
    pub cli_name: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcldir__bindgen_ty_1 {
    pub vtqe_next: *mut vcldir,
    pub vtqe_prev: *mut *mut vcldir,
}
#[test]
fn bindgen_test_layout_vcldir__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vcldir__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vcldir__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vcldir__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vcldir__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vcldir__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for vcldir__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vcldir() {
    const UNINIT: ::std::mem::MaybeUninit<vcldir> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vcldir>(),
        88usize,
        concat!("Size of: ", stringify!(vcldir))
    );
    assert_eq!(
        ::std::mem::align_of::<vcldir>(),
        8usize,
        concat!("Alignment of ", stringify!(vcldir))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlck) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(dlck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(vcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).methods) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).admin_health) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(admin_health)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).health_changed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(health_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cli_name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vcldir),
            "::",
            stringify!(cli_name)
        )
    );
}
impl Default for vcldir {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static VDI_AH_HEALTHY: *const vdi_ahealth;
}
extern "C" {
    pub static VDI_AH_SICK: *const vdi_ahealth;
}
extern "C" {
    pub static VDI_AH_AUTO: *const vdi_ahealth;
}
extern "C" {
    pub static VDI_AH_DELETED: *const vdi_ahealth;
}
pub const vfp_status_VFP_ERROR: vfp_status = -1;
pub const vfp_status_VFP_OK: vfp_status = 0;
pub const vfp_status_VFP_END: vfp_status = 1;
pub const vfp_status_VFP_NULL: vfp_status = 2;
pub type vfp_status = ::std::os::raw::c_int;
pub type vfp_init_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: *mut vfp_ctx,
        arg2: *mut vfp_entry,
    ) -> vfp_status,
>;
pub type vfp_pull_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vfp_ctx,
        arg2: *mut vfp_entry,
        ptr: *mut ::std::os::raw::c_void,
        len: *mut isize,
    ) -> vfp_status,
>;
pub type vfp_fini_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut vfp_ctx, arg2: *mut vfp_entry)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp {
    pub name: *const ::std::os::raw::c_char,
    pub init: vfp_init_f,
    pub pull: vfp_pull_f,
    pub fini: vfp_fini_f,
    pub priv1: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vfp() {
    const UNINIT: ::std::mem::MaybeUninit<vfp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp>(),
        40usize,
        concat!("Size of: ", stringify!(vfp))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pull) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(pull))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fini) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(fini))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp),
            "::",
            stringify!(priv1)
        )
    );
}
impl Default for vfp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry {
    pub magic: ::std::os::raw::c_uint,
    pub closed: vfp_status,
    pub vfp: *const vfp,
    pub priv1: *mut ::std::os::raw::c_void,
    pub priv2: isize,
    pub list: vfp_entry__bindgen_ty_1,
    pub calls: u64,
    pub bytes_out: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry__bindgen_ty_1 {
    pub vtqe_next: *mut vfp_entry,
    pub vtqe_prev: *mut *mut vfp_entry,
}
#[test]
fn bindgen_test_layout_vfp_entry__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vfp_entry__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp_entry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vfp_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for vfp_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vfp_entry() {
    const UNINIT: ::std::mem::MaybeUninit<vfp_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp_entry>(),
        64usize,
        concat!("Size of: ", stringify!(vfp_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(closed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(vfp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(priv1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(priv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calls) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(calls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_out) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(bytes_out)
        )
    );
}
impl Default for vfp_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry_s {
    pub vtqh_first: *mut vfp_entry,
    pub vtqh_last: *mut *mut vfp_entry,
}
#[test]
fn bindgen_test_layout_vfp_entry_s() {
    const UNINIT: ::std::mem::MaybeUninit<vfp_entry_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp_entry_s>(),
        16usize,
        concat!("Size of: ", stringify!(vfp_entry_s))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_entry_s>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_entry_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry_s),
            "::",
            stringify!(vtqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry_s),
            "::",
            stringify!(vtqh_last)
        )
    );
}
impl Default for vfp_entry_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub failed: ::std::os::raw::c_int,
    pub req: *mut http,
    pub resp: *mut http,
    pub wrk: *mut worker,
    pub oc: *mut objcore,
    pub vfp: vfp_entry_s,
    pub vfp_nxt: *mut vfp_entry,
    pub obj_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vfp_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<vfp_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp_ctx>(),
        72usize,
        concat!("Size of: ", stringify!(vfp_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrk) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(wrk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(oc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(vfp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfp_nxt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(vfp_nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj_flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(obj_flags)
        )
    );
}
impl Default for vfp_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VFP_Suck(
        arg1: *mut vfp_ctx,
        p: *mut ::std::os::raw::c_void,
        lp: *mut isize,
    ) -> vfp_status;
}
extern "C" {
    pub fn VFP_Error(arg1: *mut vfp_ctx, fmt: *const ::std::os::raw::c_char, ...) -> vfp_status;
}
extern "C" {
    pub fn VRT_AddVFP(ctx: *const vrt_ctx, arg1: *const vfp);
}
extern "C" {
    pub fn VRT_RemoveVFP(ctx: *const vrt_ctx, arg1: *const vfp);
}
pub const vdp_action_VDP_NULL: vdp_action = 0;
pub const vdp_action_VDP_FLUSH: vdp_action = 1;
pub const vdp_action_VDP_END: vdp_action = 2;
pub type vdp_action = ::std::os::raw::c_uint;
pub type vdp_init_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: *mut vdp_ctx,
        priv_: *mut *mut ::std::os::raw::c_void,
        arg2: *mut objcore,
    ) -> ::std::os::raw::c_int,
>;
pub type vdp_fini_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vdp_ctx,
        priv_: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type vdp_bytes_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vdp_ctx,
        arg2: vdp_action,
        priv_: *mut *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
        len: isize,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp {
    pub name: *const ::std::os::raw::c_char,
    pub init: vdp_init_f,
    pub bytes: vdp_bytes_f,
    pub fini: vdp_fini_f,
    pub priv1: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vdp() {
    const UNINIT: ::std::mem::MaybeUninit<vdp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp>(),
        40usize,
        concat!("Size of: ", stringify!(vdp))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(vdp), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(vdp), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fini) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(vdp), "::", stringify!(fini))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp),
            "::",
            stringify!(priv1)
        )
    );
}
impl Default for vdp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry {
    pub magic: ::std::os::raw::c_uint,
    pub end: vdp_action,
    pub vdp: *const vdp,
    pub priv_: *mut ::std::os::raw::c_void,
    pub list: vdp_entry__bindgen_ty_1,
    pub calls: u64,
    pub bytes_in: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry__bindgen_ty_1 {
    pub vtqe_next: *mut vdp_entry,
    pub vtqe_prev: *mut *mut vdp_entry,
}
#[test]
fn bindgen_test_layout_vdp_entry__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vdp_entry__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp_entry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vdp_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for vdp_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vdp_entry() {
    const UNINIT: ::std::mem::MaybeUninit<vdp_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp_entry>(),
        56usize,
        concat!("Size of: ", stringify!(vdp_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(vdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calls) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(calls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_in) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(bytes_in)
        )
    );
}
impl Default for vdp_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry_s {
    pub vtqh_first: *mut vdp_entry,
    pub vtqh_last: *mut *mut vdp_entry,
}
#[test]
fn bindgen_test_layout_vdp_entry_s() {
    const UNINIT: ::std::mem::MaybeUninit<vdp_entry_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp_entry_s>(),
        16usize,
        concat!("Size of: ", stringify!(vdp_entry_s))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_entry_s>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_entry_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry_s),
            "::",
            stringify!(vtqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry_s),
            "::",
            stringify!(vtqh_last)
        )
    );
}
impl Default for vdp_entry_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub retval: ::std::os::raw::c_int,
    pub bytes_done: u64,
    pub vdp: vdp_entry_s,
    pub nxt: *mut vdp_entry,
    pub wrk: *mut worker,
    pub vsl: *mut vsl_log,
    pub req: *mut req,
}
#[test]
fn bindgen_test_layout_vdp_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<vdp_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp_ctx>(),
        64usize,
        concat!("Size of: ", stringify!(vdp_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(retval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_done) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(bytes_done)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(vdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nxt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrk) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(wrk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(req)
        )
    );
}
impl Default for vdp_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VDP_bytes(
        arg1: *mut vdp_ctx,
        act: vdp_action,
        arg2: *const ::std::os::raw::c_void,
        arg3: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_AddVDP(ctx: *const vrt_ctx, arg1: *const vdp);
}
extern "C" {
    pub fn VRT_RemoveVDP(ctx: *const vrt_ctx, arg1: *const vdp);
}
extern "C" {
    pub fn VRT_AddFilter(
        ctx: *const vrt_ctx,
        arg1: *const vfp,
        arg2: *const vdp,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VRT_RemoveFilter(ctx: *const vrt_ctx, arg1: *const vfp, arg2: *const vdp);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsb {
    pub magic: ::std::os::raw::c_uint,
    pub s_error: ::std::os::raw::c_int,
    pub s_buf: *mut ::std::os::raw::c_char,
    pub s_size: isize,
    pub s_len: isize,
    pub s_flags: ::std::os::raw::c_int,
    pub s_indent: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vsb() {
    const UNINIT: ::std::mem::MaybeUninit<vsb> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vsb>(),
        40usize,
        concat!("Size of: ", stringify!(vsb))
    );
    assert_eq!(
        ::std::mem::align_of::<vsb>(),
        8usize,
        concat!("Alignment of ", stringify!(vsb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_error) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_indent) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_indent)
        )
    );
}
impl Default for vsb {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VSB_init(arg1: *mut vsb, arg2: *mut ::std::os::raw::c_void, arg3: isize) -> *mut vsb;
}
extern "C" {
    pub fn VSB_new_auto() -> *mut vsb;
}
extern "C" {
    pub fn VSB_clear(arg1: *mut vsb);
}
extern "C" {
    pub fn VSB_bcat(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_void,
        arg3: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_cat(arg1: *mut vsb, arg2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_printf(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_vprintf(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_putc(arg1: *mut vsb, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_error(arg1: *const vsb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_finish(arg1: *mut vsb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_data(arg1: *const vsb) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn VSB_len(arg1: *const vsb) -> isize;
}
extern "C" {
    pub fn VSB_fini(arg1: *mut vsb);
}
extern "C" {
    pub fn VSB_destroy(arg1: *mut *mut vsb);
}
extern "C" {
    pub fn VSB_quote_pfx(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        how: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn VSB_quote(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        how: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn VSB_indent(arg1: *mut vsb, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn VSB_tofile(arg1: *const vsb, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static vsa_suckaddr_len: usize;
}
extern "C" {
    pub static mut bogo_ip: *const suckaddr;
}
extern "C" {
    pub static mut bogo_ip6: *const suckaddr;
}
extern "C" {
    pub fn VSA_Init();
}
extern "C" {
    pub fn VSA_Sane(arg1: *const suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSA_Port(arg1: *const suckaddr) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn VSA_Compare(arg1: *const suckaddr, arg2: *const suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSA_Compare_IP(arg1: *const suckaddr, arg2: *const suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSA_Clone(sua: *const suckaddr) -> *const suckaddr;
}
extern "C" {
    pub fn VSA_getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> *const suckaddr;
}
extern "C" {
    pub fn VSA_getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> *const suckaddr;
}
extern "C" {
    pub fn VSA_free(arg1: *mut *const suckaddr);
}
extern "C" {
    pub fn VSA_Get_Sockaddr(
        arg1: *const suckaddr,
        sl: *mut socklen_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn VSA_Get_Proto(arg1: *const suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSA_Malloc(
        s: *const ::std::os::raw::c_void,
        sal: ::std::os::raw::c_uint,
    ) -> *const suckaddr;
}
extern "C" {
    pub fn VSA_Build(
        d: *mut ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        sal: ::std::os::raw::c_uint,
    ) -> *const suckaddr;
}
extern "C" {
    pub fn VSA_BuildFAP(
        d: *mut ::std::os::raw::c_void,
        fam: sa_family_t,
        a: *const ::std::os::raw::c_void,
        al: ::std::os::raw::c_uint,
        p: *const ::std::os::raw::c_void,
        pl: ::std::os::raw::c_uint,
    ) -> *const suckaddr;
}
extern "C" {
    pub fn VSA_GetPtr(
        sua: *const suckaddr,
        dst: *mut *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsm_fantom {
    pub priv_: usize,
    pub priv2: usize,
    pub b: *mut ::std::os::raw::c_void,
    pub e: *mut ::std::os::raw::c_void,
    pub category: *mut ::std::os::raw::c_char,
    pub ident: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_vsm_fantom() {
    const UNINIT: ::std::mem::MaybeUninit<vsm_fantom> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vsm_fantom>(),
        48usize,
        concat!("Size of: ", stringify!(vsm_fantom))
    );
    assert_eq!(
        ::std::mem::align_of::<vsm_fantom>(),
        8usize,
        concat!("Alignment of ", stringify!(vsm_fantom))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vsm_fantom),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vsm_fantom),
            "::",
            stringify!(priv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vsm_fantom),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vsm_fantom),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vsm_fantom),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ident) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vsm_fantom),
            "::",
            stringify!(ident)
        )
    );
}
impl Default for vsm_fantom {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VSM_New() -> *mut vsm;
}
extern "C" {
    pub fn VSM_Destroy(vd: *mut *mut vsm);
}
extern "C" {
    pub fn VSM_Error(vd: *const vsm) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VSM_ResetError(vd: *mut vsm);
}
extern "C" {
    pub fn VSM_Arg(
        arg1: *mut vsm,
        flag: ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSM_Attach(arg1: *mut vsm, progress: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSM_Status(arg1: *mut vsm) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn VSM__iter0(arg1: *const vsm, vf: *mut vsm_fantom);
}
extern "C" {
    pub fn VSM__itern(arg1: *mut vsm, vf: *mut vsm_fantom) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSM_Map(arg1: *mut vsm, vf: *mut vsm_fantom) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSM_Unmap(arg1: *mut vsm, vf: *mut vsm_fantom) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsm_valid {
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_vsm_valid() {
    const UNINIT: ::std::mem::MaybeUninit<vsm_valid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vsm_valid>(),
        8usize,
        concat!("Size of: ", stringify!(vsm_valid))
    );
    assert_eq!(
        ::std::mem::align_of::<vsm_valid>(),
        8usize,
        concat!("Alignment of ", stringify!(vsm_valid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vsm_valid),
            "::",
            stringify!(name)
        )
    );
}
impl Default for vsm_valid {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static VSM_invalid: [vsm_valid; 0usize];
}
extern "C" {
    pub static VSM_valid: [vsm_valid; 0usize];
}
extern "C" {
    pub fn VSM_StillValid(arg1: *const vsm, vf: *const vsm_fantom) -> *const vsm_valid;
}
extern "C" {
    pub fn VSM_Get(
        arg1: *mut vsm,
        vf: *mut vsm_fantom,
        category: *const ::std::os::raw::c_char,
        ident: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSM_Dup(
        arg1: *mut vsm,
        category: *const ::std::os::raw::c_char,
        ident: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_level_desc {
    pub name: *const ::std::os::raw::c_char,
    pub label: *const ::std::os::raw::c_char,
    pub sdesc: *const ::std::os::raw::c_char,
    pub ldesc: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VSC_level_desc() {
    const UNINIT: ::std::mem::MaybeUninit<VSC_level_desc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VSC_level_desc>(),
        32usize,
        concat!("Size of: ", stringify!(VSC_level_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<VSC_level_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(VSC_level_desc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_level_desc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_level_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdesc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_level_desc),
            "::",
            stringify!(sdesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ldesc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_level_desc),
            "::",
            stringify!(ldesc)
        )
    );
}
impl Default for VSC_level_desc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_point {
    pub ptr: *const u64,
    pub name: *const ::std::os::raw::c_char,
    pub ctype: *const ::std::os::raw::c_char,
    pub semantics: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
    pub level: *const VSC_level_desc,
    pub sdesc: *const ::std::os::raw::c_char,
    pub ldesc: *const ::std::os::raw::c_char,
    pub priv_: *mut ::std::os::raw::c_void,
    pub raw: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_VSC_point() {
    const UNINIT: ::std::mem::MaybeUninit<VSC_point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VSC_point>(),
        72usize,
        concat!("Size of: ", stringify!(VSC_point))
    );
    assert_eq!(
        ::std::mem::align_of::<VSC_point>(),
        8usize,
        concat!("Alignment of ", stringify!(VSC_point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(ctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semantics) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(semantics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdesc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(sdesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ldesc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(ldesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VSC_point),
            "::",
            stringify!(raw)
        )
    );
}
impl Default for VSC_point {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VSC_new_f = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        pt: *const VSC_point,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VSC_destroy_f = ::std::option::Option<
    unsafe extern "C" fn(priv_: *mut ::std::os::raw::c_void, pt: *const VSC_point),
>;
pub type VSC_iter_f = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        pt: *const VSC_point,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn VSC_New() -> *mut vsc;
}
extern "C" {
    pub fn VSC_Destroy(arg1: *mut *mut vsc, arg2: *mut vsm);
}
extern "C" {
    pub fn VSC_Arg(
        arg1: *mut vsc,
        arg: ::std::os::raw::c_char,
        opt: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSC_State(
        arg1: *mut vsc,
        arg2: VSC_new_f,
        arg3: VSC_destroy_f,
        arg4: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn VSC_Iter(
        arg1: *mut vsc,
        arg2: *mut vsm,
        arg3: VSC_iter_f,
        priv_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSC_ChangeLevel(
        arg1: *const VSC_level_desc,
        arg2: ::std::os::raw::c_int,
    ) -> *const VSC_level_desc;
}
extern "C" {
    pub fn VSC_IsRaw(arg1: *const vsc) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_conn {
    pub magic: ::std::os::raw::c_uint,
    pub rfd: *mut ::std::os::raw::c_int,
    pub doclose: stream_close_t,
    pub body_status: body_status_t,
    pub ws: *mut ws,
    pub rxbuf_b: *mut ::std::os::raw::c_char,
    pub rxbuf_e: *mut ::std::os::raw::c_char,
    pub pipeline_b: *mut ::std::os::raw::c_char,
    pub pipeline_e: *mut ::std::os::raw::c_char,
    pub content_length: isize,
    pub priv_: *mut ::std::os::raw::c_void,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
}
#[test]
fn bindgen_test_layout_http_conn() {
    const UNINIT: ::std::mem::MaybeUninit<http_conn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<http_conn>(),
        104usize,
        concat!("Size of: ", stringify!(http_conn))
    );
    assert_eq!(
        ::std::mem::align_of::<http_conn>(),
        8usize,
        concat!("Alignment of ", stringify!(http_conn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(rfd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doclose) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(doclose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_status) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(body_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(ws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxbuf_b) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(rxbuf_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxbuf_e) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(rxbuf_e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipeline_b) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(pipeline_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipeline_e) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(pipeline_e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_length) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(content_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_byte_timeout) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(first_byte_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).between_bytes_timeout) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(between_bytes_timeout)
        )
    );
}
impl Default for http_conn {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VFP_Push(arg1: *mut vfp_ctx, arg2: *const vfp) -> *mut vfp_entry;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vrt_priv {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v1l {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vdi_ahealth {
    pub _address: u8,
}
