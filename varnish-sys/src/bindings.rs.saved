/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _SYS_SOCKET_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const VRT_MAJOR_VERSION: u32 = 7;
pub const VRT_MINOR_VERSION: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const VRT_TYPE_MAGIC: u32 = 2839788594;
pub const VRT_CTX_MAGIC: u32 = 1807282395;
pub const VRT_BACKEND_MAGIC: u32 = 1201262187;
pub const VRT_BACKEND_PROBE_MAGIC: u32 = 2224653456;
pub const VRT_ACL_MAGIC: u32 = 2016583062;
pub const VSL_CLASS: &[u8; 4usize] = b"Log\0";
pub const VSL_SEGMENTS: u32 = 8;
pub const VSL_CLIENTMARKER: u32 = 1073741824;
pub const VSL_BACKENDMARKER: u32 = 2147483648;
pub const VSL_IDENTMASK: i64 = -3221225473;
pub const VSL_LENMASK: u32 = 65535;
pub const SLT__MAX: u32 = 256;
pub const NODEF_NOTICE: &[u8; 44usize] = b"NB: This log record is masked by default.\n\n\0";
pub const NOSUP_NOTICE : & [u8 ; 174usize] = b"\tNOTE: This tag is currently not in use in the Varnish log.\n\tIt is mentioned here to document legacy versions of the log,\n\tor reserved for possible use in future versions.\n\n\0" ;
pub const SLT_F_UNUSED: u32 = 1;
pub const SLT_F_UNSAFE: u32 = 2;
pub const SLT_F_BINARY: u32 = 4;
pub const DIGEST_LEN: u32 = 32;
pub const WS_MAGIC: u32 = 905626964;
pub const HTTP_MAGIC: u32 = 1680389577;
pub const HDF_FILTER: u32 = 1;
pub const VRT_PRIVS_MAGIC: u32 = 62551297;
pub const WORKER_MAGIC: u32 = 1670491599;
pub const BOC_MAGIC: u32 = 1892254838;
pub const OBJCORE_MAGIC: u32 = 1294996226;
pub const BUSYOBJ_MAGIC: u32 = 599348583;
pub const REQ_MAGIC: u32 = 659663521;
pub const RES_LEN: u32 = 2;
pub const RES_EOF: u32 = 4;
pub const RES_CHUNKED: u32 = 8;
pub const RES_ESI: u32 = 16;
pub const RES_ESI_CHILD: u32 = 32;
pub const RES_GUNZIP: u32 = 64;
pub const RES_PIPE: u32 = 128;
pub const SESS_MAGIC: u32 = 741317722;
pub const HTTPH_R_PASS: u32 = 1;
pub const HTTPH_R_FETCH: u32 = 2;
pub const HTTPH_A_INS: u32 = 4;
pub const HTTPH_A_PASS: u32 = 8;
pub const HTTPH_C_SPECIFIC: u32 = 16;
pub const P: u32 = 1;
pub const F: u32 = 2;
pub const I: u32 = 4;
pub const S: u32 = 8;
pub const K: u32 = 16;
pub const DIRECTOR_MAGIC: u32 = 859190557;
pub const VFP_ENTRY_MAGIC: u32 = 3190988839;
pub const VFP_CTX_MAGIC: u32 = 1641665509;
pub const VDP_ENTRY_MAGIC: u32 = 893302657;
pub const VDP_CTX_MAGIC: u32 = 3998227959;
pub const VMOD_ABI_Version: &[u8; 56usize] =
    b"Varnish 6.0.11 a3bc025c2df28e4a76e10c2c41217c9864e9963b\0";
pub const VSB_MAGIC: u32 = 1250090378;
pub const VSB_FIXEDLEN: u32 = 0;
pub const VSB_AUTOEXTEND: u32 = 1;
pub const VSB_USRFLAGMSK: u32 = 65535;
pub const VSB_DYNAMIC: u32 = 65536;
pub const VSB_FINISHED: u32 = 131072;
pub const VSB_DYNSTRUCT: u32 = 524288;
pub const VSB_QUOTE_NONL: u32 = 1;
pub const VSB_QUOTE_JSON: u32 = 2;
pub const VSB_QUOTE_HEX: u32 = 4;
pub const VSB_QUOTE_CSTR: u32 = 8;
pub const VSB_QUOTE_UNSAFE: u32 = 16;
pub const HTTP_CONN_MAGIC: u32 = 1041886673;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MSG_OOB: _bindgen_ty_1 = 1;
pub const MSG_PEEK: _bindgen_ty_1 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_1 = 4;
pub const MSG_CTRUNC: _bindgen_ty_1 = 8;
pub const MSG_PROXY: _bindgen_ty_1 = 16;
pub const MSG_TRUNC: _bindgen_ty_1 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_1 = 64;
pub const MSG_EOR: _bindgen_ty_1 = 128;
pub const MSG_WAITALL: _bindgen_ty_1 = 256;
pub const MSG_FIN: _bindgen_ty_1 = 512;
pub const MSG_SYN: _bindgen_ty_1 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_1 = 2048;
pub const MSG_RST: _bindgen_ty_1 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_1 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_1 = 16384;
pub const MSG_MORE: _bindgen_ty_1 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_1 = 65536;
pub const MSG_BATCH: _bindgen_ty_1 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_1 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_1 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_1 = 1073741824;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cmsg_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<osockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: _bindgen_ty_3 = 0;
pub const SHUT_WR: _bindgen_ty_3 = 1;
pub const SHUT_RDWR: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_4 = 0;
pub const FP_INFINITE: _bindgen_ty_4 = 1;
pub const FP_ZERO: _bindgen_ty_4 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_4 = 3;
pub const FP_NORMAL: _bindgen_ty_4 = 4;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_5 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_5 = 1;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_6 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_6 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_6 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_6 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_6 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_6 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_6 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_6 = 0;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_7 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_7 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_7 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_8 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_8 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_9 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_9 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_9 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_9 = 0;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_10 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_11 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_12 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_12 = 1;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
impl Default for _pthread_cleanup_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_13 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_14 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_14 = 1;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__cancel_jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
impl Default for __pthread_unwind_buf_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
impl Default for __pthread_cleanup_frame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type vtim_mono = f64;
pub type vtim_real = f64;
pub type vtim_dur = f64;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_conf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stevedore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct suckaddr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsc_seg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsmw_cluster {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_main {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strands {
    pub n: ::std::os::raw::c_int,
    pub p: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_strands() {
    const UNINIT: ::std::mem::MaybeUninit<strands> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<strands>(),
        16usize,
        concat!("Size of: ", stringify!(strands))
    );
    assert_eq!(
        ::std::mem::align_of::<strands>(),
        8usize,
        concat!("Alignment of ", stringify!(strands))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(strands),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(strands),
            "::",
            stringify!(p)
        )
    );
}
impl Default for strands {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This is the central definition of the mapping from VCL types to\n C-types.  The python scripts read these from here.\n (alphabetic order)"]
pub type VCL_ACL = *const vrt_acl;
pub type VCL_BACKEND = *const director;
pub type VCL_BLOB = *const vmod_priv;
pub type VCL_BODY = *const ::std::os::raw::c_char;
pub type VCL_BOOL = ::std::os::raw::c_uint;
pub type VCL_BYTES = i64;
pub type VCL_DURATION = vtim_dur;
pub type VCL_ENUM = *const ::std::os::raw::c_char;
pub type VCL_HEADER = *const gethdr_s;
pub type VCL_HTTP = *mut http;
pub type VCL_INSTANCE = ::std::os::raw::c_void;
pub type VCL_INT = i64;
pub type VCL_IP = *const suckaddr;
pub type VCL_PROBE = *const vrt_backend_probe;
pub type VCL_REAL = f64;
pub type VCL_STEVEDORE = *const stevedore;
pub type VCL_STRANDS = *const strands;
pub type VCL_STRING = *const ::std::os::raw::c_char;
pub type VCL_TIME = vtim_real;
pub type VCL_VCL = *mut vcl;
pub type VCL_VOID = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_type {
    pub magic: ::std::os::raw::c_uint,
    pub lname: *const ::std::os::raw::c_char,
    pub uname: *const ::std::os::raw::c_char,
    pub ctype: *const ::std::os::raw::c_char,
    pub szof: usize,
}
#[test]
fn bindgen_test_layout_vrt_type() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_type>(),
        40usize,
        concat!("Size of: ", stringify!(vrt_type))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_type>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_type),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_type),
            "::",
            stringify!(lname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uname) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_type),
            "::",
            stringify!(uname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctype) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_type),
            "::",
            stringify!(ctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szof) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_type),
            "::",
            stringify!(szof)
        )
    );
}
impl Default for vrt_type {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This is the composite argument we pass to compiled VCL and VRT\n functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub syntax: ::std::os::raw::c_uint,
    pub method: ::std::os::raw::c_uint,
    pub handling: *mut ::std::os::raw::c_uint,
    pub vclver: ::std::os::raw::c_uint,
    pub msg: *mut vsb,
    pub vsl: *mut vsl_log,
    pub vcl: *mut vcl,
    pub ws: *mut ws,
    pub sp: *mut sess,
    pub req: *mut req,
    pub http_req: *mut http,
    pub http_req_top: *mut http,
    pub http_resp: *mut http,
    pub bo: *mut busyobj,
    pub http_bereq: *mut http,
    pub http_beresp: *mut http,
    pub now: vtim_real,
    pub specific: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vrt_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_ctx>(),
        144usize,
        concat!("Size of: ", stringify!(vrt_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syntax) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handling) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(handling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vclver) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vclver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(ws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_req) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_req_top) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_req_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_resp) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bo) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(bo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_bereq) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_bereq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http_beresp) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_beresp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).now) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(now)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).specific) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(specific)
        )
    );
}
impl Default for vrt_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This is the interface structure to a compiled VMOD"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_data {
    pub vrt_major: ::std::os::raw::c_uint,
    pub vrt_minor: ::std::os::raw::c_uint,
    pub file_id: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub func: *const ::std::os::raw::c_void,
    pub func_len: ::std::os::raw::c_int,
    pub proto: *const ::std::os::raw::c_char,
    pub json: *const ::std::os::raw::c_char,
    pub abi: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_vmod_data() {
    const UNINIT: ::std::mem::MaybeUninit<vmod_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vmod_data>(),
        64usize,
        concat!("Size of: ", stringify!(vmod_data))
    );
    assert_eq!(
        ::std::mem::align_of::<vmod_data>(),
        8usize,
        concat!("Alignment of ", stringify!(vmod_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vrt_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(vrt_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vrt_minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(vrt_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(file_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func_len) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(func_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).json) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(json)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abi) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(abi)
        )
    );
}
impl Default for vmod_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vcl_event_e_VCL_EVENT_LOAD: vcl_event_e = 0;
pub const vcl_event_e_VCL_EVENT_WARM: vcl_event_e = 1;
pub const vcl_event_e_VCL_EVENT_COLD: vcl_event_e = 2;
pub const vcl_event_e_VCL_EVENT_DISCARD: vcl_event_e = 3;
#[doc = " Enum for events sent to compiled VCL and from there to Vmods"]
pub type vcl_event_e = ::std::os::raw::c_uint;
extern "C" {
    pub static vrt_magic_string_end: *const ::std::os::raw::c_void;
}
extern "C" {
    pub static vrt_magic_string_unset: *const ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_backend {
    pub magic: ::std::os::raw::c_uint,
    pub vcl_name: *const ::std::os::raw::c_char,
    pub ipv4_addr: *const ::std::os::raw::c_char,
    pub ipv6_addr: *const ::std::os::raw::c_char,
    pub port: *const ::std::os::raw::c_char,
    pub path: *const ::std::os::raw::c_char,
    pub hosthdr: *const ::std::os::raw::c_char,
    pub connect_timeout: vtim_dur,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
    pub max_connections: ::std::os::raw::c_uint,
    pub proxy_header: ::std::os::raw::c_uint,
    pub ipv4_suckaddr: *const suckaddr,
    pub ipv6_suckaddr: *const suckaddr,
    pub probe: *const vrt_backend_probe,
}
#[test]
fn bindgen_test_layout_vrt_backend() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_backend> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_backend>(),
        112usize,
        concat!("Size of: ", stringify!(vrt_backend))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_backend>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_backend))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(vcl_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv4_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(ipv4_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(ipv6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hosthdr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(hosthdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_timeout) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(connect_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_byte_timeout) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(first_byte_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).between_bytes_timeout) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(between_bytes_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_connections) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(max_connections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proxy_header) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(proxy_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv4_suckaddr) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(ipv4_suckaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6_suckaddr) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(ipv6_suckaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).probe) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(probe)
        )
    );
}
impl Default for vrt_backend {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_backend_probe {
    pub magic: ::std::os::raw::c_uint,
    pub url: *const ::std::os::raw::c_char,
    pub request: *const ::std::os::raw::c_char,
    pub timeout: vtim_dur,
    pub interval: vtim_dur,
    pub exp_status: ::std::os::raw::c_uint,
    pub window: ::std::os::raw::c_uint,
    pub threshold: ::std::os::raw::c_uint,
    pub initial: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vrt_backend_probe() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_backend_probe> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_backend_probe>(),
        56usize,
        concat!("Size of: ", stringify!(vrt_backend_probe))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_backend_probe>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_backend_probe))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).url) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exp_status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(exp_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(initial)
        )
    );
}
impl Default for vrt_backend_probe {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " VRT_count() refers to this structure for coordinates into the VCL source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_ref {
    pub source: ::std::os::raw::c_uint,
    pub offset: ::std::os::raw::c_uint,
    pub line: ::std::os::raw::c_uint,
    pub pos: ::std::os::raw::c_uint,
    pub token: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_vrt_ref() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_ref> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_ref>(),
        24usize,
        concat!("Size of: ", stringify!(vrt_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_ref>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_ref))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ref),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ref),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ref),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ref),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ref),
            "::",
            stringify!(token)
        )
    );
}
impl Default for vrt_ref {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_count(ctx: *const vrt_ctx, arg1: ::std::os::raw::c_uint);
}
#[doc = " Implementation details of ACLs"]
pub type acl_match_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_IP) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vrt_acl {
    pub magic: ::std::os::raw::c_uint,
    pub match_: acl_match_f,
}
#[test]
fn bindgen_test_layout_vrt_acl() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_acl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_acl>(),
        16usize,
        concat!("Size of: ", stringify!(vrt_acl))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_acl>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_acl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_acl),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_acl),
            "::",
            stringify!(match_)
        )
    );
}
extern "C" {
    pub fn VRT_acl_log(ctx: *const vrt_ctx, arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VRT_acl_match(ctx: *const vrt_ctx, arg1: VCL_ACL, arg2: VCL_IP)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compile time regexp"]
    pub fn VRT_re_init(arg1: *mut *mut ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn VRT_re_fini(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn VRT_re_match(
        ctx: *const vrt_ctx,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const gethdr_e_HDR_REQ: gethdr_e = 0;
pub const gethdr_e_HDR_REQ_TOP: gethdr_e = 1;
pub const gethdr_e_HDR_RESP: gethdr_e = 2;
pub const gethdr_e_HDR_OBJ: gethdr_e = 3;
pub const gethdr_e_HDR_BEREQ: gethdr_e = 4;
pub const gethdr_e_HDR_BERESP: gethdr_e = 5;
#[doc = " Getting hold of the various struct http"]
pub type gethdr_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gethdr_s {
    pub where_: gethdr_e,
    pub what: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_gethdr_s() {
    const UNINIT: ::std::mem::MaybeUninit<gethdr_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gethdr_s>(),
        16usize,
        concat!("Size of: ", stringify!(gethdr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<gethdr_s>(),
        8usize,
        concat!("Alignment of ", stringify!(gethdr_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).where_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gethdr_s),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).what) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gethdr_s),
            "::",
            stringify!(what)
        )
    );
}
impl Default for gethdr_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_selecthttp(ctx: *const vrt_ctx, arg1: gethdr_e) -> VCL_HTTP;
}
extern "C" {
    pub fn VRT_GetHdr(ctx: *const vrt_ctx, arg1: *const gethdr_s) -> VCL_STRING;
}
extern "C" {
    #[doc = " req related"]
    pub fn VRT_CacheReqBody(ctx: *const vrt_ctx, maxsize: VCL_BYTES) -> VCL_BYTES;
}
extern "C" {
    pub fn VRT_regsub(
        ctx: *const vrt_ctx,
        all: ::std::os::raw::c_int,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VRT_ban_string(ctx: *const vrt_ctx, arg1: VCL_STRING);
}
extern "C" {
    pub fn VRT_purge(
        ctx: *const vrt_ctx,
        arg1: VCL_DURATION,
        arg2: VCL_DURATION,
        arg3: VCL_DURATION,
    ) -> VCL_INT;
}
extern "C" {
    pub fn VRT_synth(ctx: *const vrt_ctx, arg1: VCL_INT, arg2: VCL_STRING);
}
extern "C" {
    pub fn VRT_hit_for_pass(ctx: *const vrt_ctx, arg1: VCL_DURATION);
}
extern "C" {
    pub fn VRT_SetHdr(
        ctx: *const vrt_ctx,
        arg1: *const gethdr_s,
        arg2: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn VRT_handling(ctx: *const vrt_ctx, hand: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn VRT_fail(ctx: *const vrt_ctx, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VRT_hashdata(ctx: *const vrt_ctx, str_: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VRT_strcmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_memmove(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn VRT_ipcmp(arg1: VCL_IP, arg2: VCL_IP) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_blob(
        ctx: *const vrt_ctx,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> VCL_BLOB;
}
extern "C" {
    pub fn VRT_Rollback(ctx: *const vrt_ctx, arg1: VCL_HTTP);
}
extern "C" {
    pub fn VRT_synth_page(ctx: *const vrt_ctx, arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VRT_new_backend(ctx: *const vrt_ctx, arg1: *const vrt_backend) -> *mut director;
}
extern "C" {
    pub fn VRT_new_backend_clustered(
        ctx: *const vrt_ctx,
        arg1: *mut vsmw_cluster,
        arg2: *const vrt_backend,
    ) -> *mut director;
}
extern "C" {
    pub fn VRT_backend_vsm_need(ctx: *const vrt_ctx) -> usize;
}
extern "C" {
    pub fn VRT_delete_backend(ctx: *const vrt_ctx, arg1: *mut *mut director);
}
extern "C" {
    pub fn VRT_backend_healthy(ctx: *const vrt_ctx, arg1: *mut director) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_VSM_Cluster_New(ctx: *const vrt_ctx, arg1: usize) -> *mut vsmw_cluster;
}
extern "C" {
    pub fn VRT_VSM_Cluster_Destroy(ctx: *const vrt_ctx, arg1: *mut *mut vsmw_cluster);
}
extern "C" {
    pub fn VRT_Healthy(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_VSA_GetPtr(
        sua: *const suckaddr,
        dst: *mut *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_Vmod_Init(
        ctx: *const vrt_ctx,
        hdl: *mut *mut vmod,
        nbr: ::std::os::raw::c_uint,
        ptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        nm: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
        file_id: *const ::std::os::raw::c_char,
        backup: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_Vmod_Unload(ctx: *const vrt_ctx, hdl: *mut *mut vmod);
}
extern "C" {
    pub fn VRT_vcl_get(ctx: *const vrt_ctx, arg1: *const ::std::os::raw::c_char) -> VCL_VCL;
}
extern "C" {
    pub fn VRT_vcl_rel(ctx: *const vrt_ctx, arg1: VCL_VCL);
}
extern "C" {
    pub fn VRT_vcl_select(ctx: *const vrt_ctx, arg1: VCL_VCL);
}
pub type vmod_event_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: *mut vmod_priv,
        arg2: vcl_event_e,
    ) -> ::std::os::raw::c_int,
>;
pub type vmod_priv_free_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_priv {
    pub priv_: *mut ::std::os::raw::c_void,
    pub len: ::std::os::raw::c_int,
    pub free: vmod_priv_free_f,
}
#[test]
fn bindgen_test_layout_vmod_priv() {
    const UNINIT: ::std::mem::MaybeUninit<vmod_priv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vmod_priv>(),
        24usize,
        concat!("Size of: ", stringify!(vmod_priv))
    );
    assert_eq!(
        ::std::mem::align_of::<vmod_priv>(),
        8usize,
        concat!("Alignment of ", stringify!(vmod_priv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv),
            "::",
            stringify!(free)
        )
    );
}
impl Default for vmod_priv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vclref {
    _unused: [u8; 0],
}
extern "C" {
    pub fn VRT_ref_vcl(ctx: *const vrt_ctx, arg1: *const ::std::os::raw::c_char) -> *mut vclref;
}
extern "C" {
    pub fn VRT_rel_vcl(ctx: *const vrt_ctx, arg1: *mut *mut vclref);
}
extern "C" {
    pub fn VRT_priv_fini(p: *const vmod_priv);
}
extern "C" {
    pub fn VRT_priv_task(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    pub fn VRT_priv_top(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    pub fn VRT_Stv(nm: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_stevedore(nm: *const ::std::os::raw::c_char) -> VCL_STEVEDORE;
}
extern "C" {
    pub fn VRT_BundleStrands(
        arg1: ::std::os::raw::c_int,
        arg2: *mut strands,
        arg3: *mut *const ::std::os::raw::c_char,
        f: *const ::std::os::raw::c_char,
        ...
    ) -> VCL_STRANDS;
}
extern "C" {
    pub fn VRT_CompareStrands(a: VCL_STRANDS, b: VCL_STRANDS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_Strands(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: VCL_STRANDS,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn VRT_StrandsWS(
        arg1: *mut ws,
        arg2: *const ::std::os::raw::c_char,
        arg3: VCL_STRANDS,
    ) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_CollectStrands(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_BACKEND_string(arg1: VCL_BACKEND) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_BOOL_string(arg1: VCL_BOOL) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_CollectString(
        ctx: *const vrt_ctx,
        p: *const ::std::os::raw::c_char,
        ...
    ) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_INT_string(ctx: *const vrt_ctx, arg1: VCL_INT) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_IP_string(ctx: *const vrt_ctx, arg1: VCL_IP) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_REAL_string(ctx: *const vrt_ctx, arg1: VCL_REAL) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_STEVEDORE_string(arg1: VCL_STEVEDORE) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_TIME_string(ctx: *const vrt_ctx, arg1: VCL_TIME) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_VSC_Alloc(
        arg1: *mut vsmw_cluster,
        arg2: *mut *mut vsc_seg,
        arg3: *const ::std::os::raw::c_char,
        arg4: usize,
        arg5: *const ::std::os::raw::c_uchar,
        arg6: usize,
        arg7: *const ::std::os::raw::c_char,
        arg8: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn VRT_VSC_Destroy(arg1: *const ::std::os::raw::c_char, arg2: *mut vsc_seg);
}
extern "C" {
    pub fn VRT_VSC_Hide(arg1: *const vsc_seg);
}
extern "C" {
    pub fn VRT_VSC_Reveal(arg1: *const vsc_seg);
}
extern "C" {
    pub fn VRT_VSC_Overhead(arg1: usize) -> usize;
}
pub const vas_e_VAS_WRONG: vas_e = 0;
pub const vas_e_VAS_MISSING: vas_e = 1;
pub const vas_e_VAS_ASSERT: vas_e = 2;
pub const vas_e_VAS_INCOMPLETE: vas_e = 3;
pub const vas_e_VAS_VCL: vas_e = 4;
pub type vas_e = ::std::os::raw::c_uint;
pub type vas_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: vas_e,
    ),
>;
extern "C" {
    pub static mut VAS_Fail_Func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *const ::std::os::raw::c_char,
            arg5: vas_e,
        ) -> !,
    >;
}
extern "C" {
    pub fn VAS_Fail(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: vas_e,
    ) -> !;
}
pub const VSL_tag_e_SLT__Bogus: VSL_tag_e = 0;
pub const VSL_tag_e_SLT_Debug: VSL_tag_e = 1;
pub const VSL_tag_e_SLT_Error: VSL_tag_e = 2;
pub const VSL_tag_e_SLT_CLI: VSL_tag_e = 3;
pub const VSL_tag_e_SLT_SessOpen: VSL_tag_e = 4;
pub const VSL_tag_e_SLT_SessClose: VSL_tag_e = 5;
pub const VSL_tag_e_SLT_BackendOpen: VSL_tag_e = 6;
pub const VSL_tag_e_SLT_BackendReuse: VSL_tag_e = 7;
pub const VSL_tag_e_SLT_BackendClose: VSL_tag_e = 8;
pub const VSL_tag_e_SLT_HttpGarbage: VSL_tag_e = 9;
pub const VSL_tag_e_SLT_Proxy: VSL_tag_e = 10;
pub const VSL_tag_e_SLT_ProxyGarbage: VSL_tag_e = 11;
pub const VSL_tag_e_SLT_Backend: VSL_tag_e = 12;
pub const VSL_tag_e_SLT_Length: VSL_tag_e = 13;
pub const VSL_tag_e_SLT_FetchError: VSL_tag_e = 14;
pub const VSL_tag_e_SLT_ReqMethod: VSL_tag_e = 15;
pub const VSL_tag_e_SLT_ReqURL: VSL_tag_e = 16;
pub const VSL_tag_e_SLT_ReqProtocol: VSL_tag_e = 17;
pub const VSL_tag_e_SLT_ReqStatus: VSL_tag_e = 18;
pub const VSL_tag_e_SLT_ReqReason: VSL_tag_e = 19;
pub const VSL_tag_e_SLT_ReqHeader: VSL_tag_e = 20;
pub const VSL_tag_e_SLT_ReqUnset: VSL_tag_e = 21;
pub const VSL_tag_e_SLT_ReqLost: VSL_tag_e = 22;
pub const VSL_tag_e_SLT_RespMethod: VSL_tag_e = 23;
pub const VSL_tag_e_SLT_RespURL: VSL_tag_e = 24;
pub const VSL_tag_e_SLT_RespProtocol: VSL_tag_e = 25;
pub const VSL_tag_e_SLT_RespStatus: VSL_tag_e = 26;
pub const VSL_tag_e_SLT_RespReason: VSL_tag_e = 27;
pub const VSL_tag_e_SLT_RespHeader: VSL_tag_e = 28;
pub const VSL_tag_e_SLT_RespUnset: VSL_tag_e = 29;
pub const VSL_tag_e_SLT_RespLost: VSL_tag_e = 30;
pub const VSL_tag_e_SLT_BereqMethod: VSL_tag_e = 31;
pub const VSL_tag_e_SLT_BereqURL: VSL_tag_e = 32;
pub const VSL_tag_e_SLT_BereqProtocol: VSL_tag_e = 33;
pub const VSL_tag_e_SLT_BereqStatus: VSL_tag_e = 34;
pub const VSL_tag_e_SLT_BereqReason: VSL_tag_e = 35;
pub const VSL_tag_e_SLT_BereqHeader: VSL_tag_e = 36;
pub const VSL_tag_e_SLT_BereqUnset: VSL_tag_e = 37;
pub const VSL_tag_e_SLT_BereqLost: VSL_tag_e = 38;
pub const VSL_tag_e_SLT_BerespMethod: VSL_tag_e = 39;
pub const VSL_tag_e_SLT_BerespURL: VSL_tag_e = 40;
pub const VSL_tag_e_SLT_BerespProtocol: VSL_tag_e = 41;
pub const VSL_tag_e_SLT_BerespStatus: VSL_tag_e = 42;
pub const VSL_tag_e_SLT_BerespReason: VSL_tag_e = 43;
pub const VSL_tag_e_SLT_BerespHeader: VSL_tag_e = 44;
pub const VSL_tag_e_SLT_BerespUnset: VSL_tag_e = 45;
pub const VSL_tag_e_SLT_BerespLost: VSL_tag_e = 46;
pub const VSL_tag_e_SLT_ObjMethod: VSL_tag_e = 47;
pub const VSL_tag_e_SLT_ObjURL: VSL_tag_e = 48;
pub const VSL_tag_e_SLT_ObjProtocol: VSL_tag_e = 49;
pub const VSL_tag_e_SLT_ObjStatus: VSL_tag_e = 50;
pub const VSL_tag_e_SLT_ObjReason: VSL_tag_e = 51;
pub const VSL_tag_e_SLT_ObjHeader: VSL_tag_e = 52;
pub const VSL_tag_e_SLT_ObjUnset: VSL_tag_e = 53;
pub const VSL_tag_e_SLT_ObjLost: VSL_tag_e = 54;
pub const VSL_tag_e_SLT_BogoHeader: VSL_tag_e = 55;
pub const VSL_tag_e_SLT_LostHeader: VSL_tag_e = 56;
pub const VSL_tag_e_SLT_TTL: VSL_tag_e = 57;
pub const VSL_tag_e_SLT_Fetch_Body: VSL_tag_e = 58;
pub const VSL_tag_e_SLT_VCL_acl: VSL_tag_e = 59;
pub const VSL_tag_e_SLT_VCL_call: VSL_tag_e = 60;
pub const VSL_tag_e_SLT_VCL_trace: VSL_tag_e = 61;
pub const VSL_tag_e_SLT_VCL_return: VSL_tag_e = 62;
pub const VSL_tag_e_SLT_ReqStart: VSL_tag_e = 63;
pub const VSL_tag_e_SLT_Hit: VSL_tag_e = 64;
pub const VSL_tag_e_SLT_HitPass: VSL_tag_e = 65;
pub const VSL_tag_e_SLT_ExpBan: VSL_tag_e = 66;
pub const VSL_tag_e_SLT_ExpKill: VSL_tag_e = 67;
pub const VSL_tag_e_SLT_WorkThread: VSL_tag_e = 68;
pub const VSL_tag_e_SLT_ESI_xmlerror: VSL_tag_e = 69;
pub const VSL_tag_e_SLT_Hash: VSL_tag_e = 70;
pub const VSL_tag_e_SLT_Backend_health: VSL_tag_e = 71;
pub const VSL_tag_e_SLT_VCL_Log: VSL_tag_e = 72;
pub const VSL_tag_e_SLT_VCL_Error: VSL_tag_e = 73;
pub const VSL_tag_e_SLT_Gzip: VSL_tag_e = 74;
pub const VSL_tag_e_SLT_Link: VSL_tag_e = 75;
pub const VSL_tag_e_SLT_Begin: VSL_tag_e = 76;
pub const VSL_tag_e_SLT_End: VSL_tag_e = 77;
pub const VSL_tag_e_SLT_VSL: VSL_tag_e = 78;
pub const VSL_tag_e_SLT_Storage: VSL_tag_e = 79;
pub const VSL_tag_e_SLT_Timestamp: VSL_tag_e = 80;
pub const VSL_tag_e_SLT_ReqAcct: VSL_tag_e = 81;
pub const VSL_tag_e_SLT_PipeAcct: VSL_tag_e = 82;
pub const VSL_tag_e_SLT_BereqAcct: VSL_tag_e = 83;
pub const VSL_tag_e_SLT_VfpAcct: VSL_tag_e = 84;
pub const VSL_tag_e_SLT_Witness: VSL_tag_e = 85;
pub const VSL_tag_e_SLT_BackendStart: VSL_tag_e = 86;
pub const VSL_tag_e_SLT_H2RxHdr: VSL_tag_e = 87;
pub const VSL_tag_e_SLT_H2RxBody: VSL_tag_e = 88;
pub const VSL_tag_e_SLT_H2TxHdr: VSL_tag_e = 89;
pub const VSL_tag_e_SLT_H2TxBody: VSL_tag_e = 90;
pub const VSL_tag_e_SLT_HitMiss: VSL_tag_e = 91;
pub const VSL_tag_e_SLT_Filters: VSL_tag_e = 92;
pub const VSL_tag_e_SLT_SessError: VSL_tag_e = 93;
pub const VSL_tag_e_SLT_VCL_use: VSL_tag_e = 94;
pub const VSL_tag_e_SLT_Notice: VSL_tag_e = 95;
pub const VSL_tag_e_SLT__Reserved: VSL_tag_e = 254;
pub const VSL_tag_e_SLT__Batch: VSL_tag_e = 255;
pub type VSL_tag_e = ::std::os::raw::c_uint;
pub const body_status_BS_NONE: body_status = 0;
pub const body_status_BS_ERROR: body_status = 1;
pub const body_status_BS_CHUNKED: body_status = 2;
pub const body_status_BS_LENGTH: body_status = 3;
pub const body_status_BS_EOF: body_status = 4;
pub type body_status = ::std::os::raw::c_uint;
pub const req_body_state_e_REQ_BODY_INIT: req_body_state_e = 0;
pub const req_body_state_e_REQ_BODY_WITHOUT_LEN: req_body_state_e = 1;
pub const req_body_state_e_REQ_BODY_WITH_LEN: req_body_state_e = 2;
pub const req_body_state_e_REQ_BODY_TAKEN: req_body_state_e = 3;
pub const req_body_state_e_REQ_BODY_CACHED: req_body_state_e = 4;
pub const req_body_state_e_REQ_BODY_FAIL: req_body_state_e = 5;
pub const req_body_state_e_REQ_BODY_NONE: req_body_state_e = 6;
pub type req_body_state_e = ::std::os::raw::c_uint;
pub const sess_close_SC_NULL: sess_close = 0;
pub const sess_close_SC_REM_CLOSE: sess_close = 1;
pub const sess_close_SC_REQ_CLOSE: sess_close = 2;
pub const sess_close_SC_REQ_HTTP10: sess_close = 3;
pub const sess_close_SC_RX_BAD: sess_close = 4;
pub const sess_close_SC_RX_BODY: sess_close = 5;
pub const sess_close_SC_RX_JUNK: sess_close = 6;
pub const sess_close_SC_RX_OVERFLOW: sess_close = 7;
pub const sess_close_SC_RX_TIMEOUT: sess_close = 8;
pub const sess_close_SC_TX_PIPE: sess_close = 9;
pub const sess_close_SC_TX_ERROR: sess_close = 10;
pub const sess_close_SC_TX_EOF: sess_close = 11;
pub const sess_close_SC_RESP_CLOSE: sess_close = 12;
pub const sess_close_SC_OVERLOAD: sess_close = 13;
pub const sess_close_SC_PIPE_OVERFLOW: sess_close = 14;
pub const sess_close_SC_RANGE_SHORT: sess_close = 15;
pub const sess_close_SC_REQ_HTTP20: sess_close = 16;
pub const sess_close_SC_VCL_FAILURE: sess_close = 17;
pub type sess_close = ::std::os::raw::c_uint;
pub const HTTP_HDR_METHOD: _bindgen_ty_15 = 0;
pub const HTTP_HDR_URL: _bindgen_ty_15 = 1;
pub const HTTP_HDR_PROTO: _bindgen_ty_15 = 2;
pub const HTTP_HDR_STATUS: _bindgen_ty_15 = 3;
pub const HTTP_HDR_REASON: _bindgen_ty_15 = 4;
pub const HTTP_HDR_FIRST: _bindgen_ty_15 = 5;
pub const HTTP_HDR_UNSET: _bindgen_ty_15 = 6;
pub const HTTP_HDR_LOST: _bindgen_ty_15 = 7;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_lck {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_main_wrk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct backend {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ban {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ban_proto {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mempool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objhead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct transport {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct listen_sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct txt {
    pub b: *const ::std::os::raw::c_char,
    pub e: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_txt() {
    const UNINIT: ::std::mem::MaybeUninit<txt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<txt>(),
        16usize,
        concat!("Size of: ", stringify!(txt))
    );
    assert_eq!(
        ::std::mem::align_of::<txt>(),
        8usize,
        concat!("Alignment of ", stringify!(txt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(txt), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(txt), "::", stringify!(e))
    );
}
impl Default for txt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const req_step_R_STP_NONE: req_step = 0;
pub const req_step_R_STP_TRANSPORT: req_step = 1;
pub const req_step_R_STP_RESTART: req_step = 2;
pub const req_step_R_STP_RECV: req_step = 3;
pub const req_step_R_STP_PIPE: req_step = 4;
pub const req_step_R_STP_PASS: req_step = 5;
pub const req_step_R_STP_LOOKUP: req_step = 6;
pub const req_step_R_STP_PURGE: req_step = 7;
pub const req_step_R_STP_MISS: req_step = 8;
pub const req_step_R_STP_FETCH: req_step = 9;
pub const req_step_R_STP_DELIVER: req_step = 10;
pub const req_step_R_STP_VCLFAIL: req_step = 11;
pub const req_step_R_STP_SYNTH: req_step = 12;
pub const req_step_R_STP_TRANSMIT: req_step = 13;
pub type req_step = ::std::os::raw::c_uint;
pub const fetch_step_F_STP_NONE: fetch_step = 0;
pub const fetch_step_F_STP_MKBEREQ: fetch_step = 1;
pub const fetch_step_F_STP_RETRY: fetch_step = 2;
pub const fetch_step_F_STP_STARTFETCH: fetch_step = 3;
pub const fetch_step_F_STP_CONDFETCH: fetch_step = 4;
pub const fetch_step_F_STP_FETCH: fetch_step = 5;
pub const fetch_step_F_STP_FETCHBODY: fetch_step = 6;
pub const fetch_step_F_STP_FETCHEND: fetch_step = 7;
pub const fetch_step_F_STP_ERROR: fetch_step = 8;
pub const fetch_step_F_STP_FAIL: fetch_step = 9;
pub const fetch_step_F_STP_DONE: fetch_step = 10;
pub type fetch_step = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock {
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lock() {
    const UNINIT: ::std::mem::MaybeUninit<lock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lock>(),
        8usize,
        concat!("Size of: ", stringify!(lock))
    );
    assert_eq!(
        ::std::mem::align_of::<lock>(),
        8usize,
        concat!("Alignment of ", stringify!(lock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for lock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ws {
    pub magic: ::std::os::raw::c_uint,
    pub id: [::std::os::raw::c_char; 4usize],
    pub s: *mut ::std::os::raw::c_char,
    pub f: *mut ::std::os::raw::c_char,
    pub r: *mut ::std::os::raw::c_char,
    pub e: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ws() {
    const UNINIT: ::std::mem::MaybeUninit<ws> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ws>(),
        40usize,
        concat!("Size of: ", stringify!(ws))
    );
    assert_eq!(
        ::std::mem::align_of::<ws>(),
        8usize,
        concat!("Alignment of ", stringify!(ws))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(magic))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(e))
    );
}
impl Default for ws {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http {
    pub magic: ::std::os::raw::c_uint,
    pub shd: u16,
    pub hd: *mut txt,
    pub hdf: *mut ::std::os::raw::c_uchar,
    pub nhd: u16,
    pub logtag: VSL_tag_e,
    pub vsl: *mut vsl_log,
    pub ws: *mut ws,
    pub status: u16,
    pub protover: u8,
    pub conds: u8,
}
#[test]
fn bindgen_test_layout_http() {
    const UNINIT: ::std::mem::MaybeUninit<http> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<http>(),
        56usize,
        concat!("Size of: ", stringify!(http))
    );
    assert_eq!(
        ::std::mem::align_of::<http>(),
        8usize,
        concat!("Alignment of ", stringify!(http))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shd) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(shd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hd) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(hd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdf) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(hdf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nhd) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(nhd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logtag) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(logtag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(vsl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(ws))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protover) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(protover)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conds) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(conds)
        )
    );
}
impl Default for http {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acct_req {
    pub req_hdrbytes: u64,
    pub req_bodybytes: u64,
    pub resp_hdrbytes: u64,
    pub resp_bodybytes: u64,
}
#[test]
fn bindgen_test_layout_acct_req() {
    const UNINIT: ::std::mem::MaybeUninit<acct_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<acct_req>(),
        32usize,
        concat!("Size of: ", stringify!(acct_req))
    );
    assert_eq!(
        ::std::mem::align_of::<acct_req>(),
        8usize,
        concat!("Alignment of ", stringify!(acct_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_hdrbytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(req_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_bodybytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(req_bodybytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_hdrbytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(resp_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_bodybytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(resp_bodybytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acct_bereq {
    pub bereq_hdrbytes: u64,
    pub bereq_bodybytes: u64,
    pub beresp_hdrbytes: u64,
    pub beresp_bodybytes: u64,
}
#[test]
fn bindgen_test_layout_acct_bereq() {
    const UNINIT: ::std::mem::MaybeUninit<acct_bereq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<acct_bereq>(),
        32usize,
        concat!("Size of: ", stringify!(acct_bereq))
    );
    assert_eq!(
        ::std::mem::align_of::<acct_bereq>(),
        8usize,
        concat!("Alignment of ", stringify!(acct_bereq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq_hdrbytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(bereq_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq_bodybytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(bereq_bodybytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beresp_hdrbytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(beresp_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beresp_bodybytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(beresp_bodybytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_log {
    pub wlb: *mut u32,
    pub wlp: *mut u32,
    pub wle: *mut u32,
    pub wlr: ::std::os::raw::c_uint,
    pub wid: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vsl_log() {
    const UNINIT: ::std::mem::MaybeUninit<vsl_log> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vsl_log>(),
        32usize,
        concat!("Size of: ", stringify!(vsl_log))
    );
    assert_eq!(
        ::std::mem::align_of::<vsl_log>(),
        8usize,
        concat!("Alignment of ", stringify!(vsl_log))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wlb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wlb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wlp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wlp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wlr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wlr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wid)
        )
    );
}
impl Default for vsl_log {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vxid_pool {
    pub next: u32,
    pub count: u32,
}
#[test]
fn bindgen_test_layout_vxid_pool() {
    const UNINIT: ::std::mem::MaybeUninit<vxid_pool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vxid_pool>(),
        8usize,
        concat!("Size of: ", stringify!(vxid_pool))
    );
    assert_eq!(
        ::std::mem::align_of::<vxid_pool>(),
        4usize,
        concat!("Alignment of ", stringify!(vxid_pool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vxid_pool),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vxid_pool),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_privs {
    pub magic: ::std::os::raw::c_uint,
    pub privs: vrt_privs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_privs__bindgen_ty_1 {
    pub vtqh_first: *mut vrt_priv,
    pub vtqh_last: *mut *mut vrt_priv,
}
#[test]
fn bindgen_test_layout_vrt_privs__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_privs__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_privs__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vrt_privs__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_privs__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_privs__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_privs__bindgen_ty_1),
            "::",
            stringify!(vtqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_privs__bindgen_ty_1),
            "::",
            stringify!(vtqh_last)
        )
    );
}
impl Default for vrt_privs__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vrt_privs() {
    const UNINIT: ::std::mem::MaybeUninit<vrt_privs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vrt_privs>(),
        24usize,
        concat!("Size of: ", stringify!(vrt_privs))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_privs>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_privs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_privs),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).privs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_privs),
            "::",
            stringify!(privs)
        )
    );
}
impl Default for vrt_privs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type task_func_t = ::std::option::Option<
    unsafe extern "C" fn(wrk: *mut worker, priv_: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool_task {
    pub list: pool_task__bindgen_ty_1,
    pub func: task_func_t,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool_task__bindgen_ty_1 {
    pub vtqe_next: *mut pool_task,
    pub vtqe_prev: *mut *mut pool_task,
}
#[test]
fn bindgen_test_layout_pool_task__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pool_task__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pool_task__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(pool_task__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pool_task__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pool_task__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for pool_task__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_pool_task() {
    const UNINIT: ::std::mem::MaybeUninit<pool_task> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pool_task>(),
        32usize,
        concat!("Size of: ", stringify!(pool_task))
    );
    assert_eq!(
        ::std::mem::align_of::<pool_task>(),
        8usize,
        concat!("Alignment of ", stringify!(pool_task))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for pool_task {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const task_prio_TASK_QUEUE_BO: task_prio = 0;
pub const task_prio_TASK_QUEUE_RUSH: task_prio = 1;
pub const task_prio_TASK_QUEUE_REQ: task_prio = 2;
pub const task_prio_TASK_QUEUE_STR: task_prio = 3;
pub const task_prio_TASK_QUEUE_VCA: task_prio = 4;
pub const task_prio_TASK_QUEUE__END: task_prio = 5;
pub type task_prio = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct worker {
    pub magic: ::std::os::raw::c_uint,
    pub pool: *mut pool,
    pub nobjhead: *mut objhead,
    pub nobjcore: *mut objcore,
    pub nhashpriv: *mut ::std::os::raw::c_void,
    pub stats: *mut VSC_main_wrk,
    pub vsl: *mut vsl_log,
    pub task: pool_task,
    pub lastused: vtim_real,
    pub strangelove: ::std::os::raw::c_int,
    pub v1l: *mut v1l,
    pub cond: pthread_cond_t,
    pub vcl: *mut vcl,
    pub aws: [ws; 1usize],
    pub vxid_pool: vxid_pool,
    pub cur_method: ::std::os::raw::c_uint,
    pub seen_methods: ::std::os::raw::c_uint,
    pub handling: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_worker() {
    const UNINIT: ::std::mem::MaybeUninit<worker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<worker>(),
        232usize,
        concat!("Size of: ", stringify!(worker))
    );
    assert_eq!(
        ::std::mem::align_of::<worker>(),
        8usize,
        concat!("Alignment of ", stringify!(worker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nobjhead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(nobjhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nobjcore) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(nobjcore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nhashpriv) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(nhashpriv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stats) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastused) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(lastused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strangelove) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(strangelove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v1l) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(v1l)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(vcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aws) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(aws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vxid_pool) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(vxid_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_method) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(cur_method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seen_methods) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(seen_methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handling) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(handling)
        )
    );
}
impl Default for worker {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct storeobj {
    pub stevedore: *const stevedore,
    pub priv_: *mut ::std::os::raw::c_void,
    pub priv2: usize,
}
#[test]
fn bindgen_test_layout_storeobj() {
    const UNINIT: ::std::mem::MaybeUninit<storeobj> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<storeobj>(),
        24usize,
        concat!("Size of: ", stringify!(storeobj))
    );
    assert_eq!(
        ::std::mem::align_of::<storeobj>(),
        8usize,
        concat!("Alignment of ", stringify!(storeobj))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stevedore) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(storeobj),
            "::",
            stringify!(stevedore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(storeobj),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(storeobj),
            "::",
            stringify!(priv2)
        )
    );
}
impl Default for storeobj {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const boc_state_e_BOS_INVALID: boc_state_e = 0;
pub const boc_state_e_BOS_REQ_DONE: boc_state_e = 1;
pub const boc_state_e_BOS_PREP_STREAM: boc_state_e = 2;
pub const boc_state_e_BOS_STREAM: boc_state_e = 3;
pub const boc_state_e_BOS_FINISHED: boc_state_e = 4;
pub const boc_state_e_BOS_FAILED: boc_state_e = 5;
pub type boc_state_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct boc {
    pub magic: ::std::os::raw::c_uint,
    pub refcount: ::std::os::raw::c_uint,
    pub mtx: lock,
    pub cond: pthread_cond_t,
    pub stevedore_priv: *mut ::std::os::raw::c_void,
    pub state: boc_state_e,
    pub vary: *mut u8,
    pub len_so_far: u64,
}
#[test]
fn bindgen_test_layout_boc() {
    const UNINIT: ::std::mem::MaybeUninit<boc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<boc>(),
        96usize,
        concat!("Size of: ", stringify!(boc))
    );
    assert_eq!(
        ::std::mem::align_of::<boc>(),
        8usize,
        concat!("Alignment of ", stringify!(boc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtx) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(boc), "::", stringify!(mtx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(boc), "::", stringify!(cond))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stevedore_priv) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(stevedore_priv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vary) as usize - ptr as usize },
        80usize,
        concat!("Offset of field: ", stringify!(boc), "::", stringify!(vary))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len_so_far) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(len_so_far)
        )
    );
}
impl Default for boc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const obj_attr_OA_LEN: obj_attr = 0;
pub const obj_attr_OA_VXID: obj_attr = 1;
pub const obj_attr_OA_FLAGS: obj_attr = 2;
pub const obj_attr_OA_GZIPBITS: obj_attr = 3;
pub const obj_attr_OA_LASTMODIFIED: obj_attr = 4;
pub const obj_attr_OA_VARY: obj_attr = 5;
pub const obj_attr_OA_HEADERS: obj_attr = 6;
pub const obj_attr_OA_ESIDATA: obj_attr = 7;
pub const obj_attr_OA__MAX: obj_attr = 8;
pub type obj_attr = ::std::os::raw::c_uint;
pub const obj_flags_OF_GZIPED: obj_flags = 2;
pub const obj_flags_OF_CHGGZIP: obj_flags = 4;
pub const obj_flags_OF_IMSCAND: obj_flags = 8;
pub const obj_flags_OF_ESIPROC: obj_flags = 16;
pub type obj_flags = ::std::os::raw::c_uint;
pub const oc_flags_OC_F_PURGED: oc_flags = 1;
pub const oc_flags_OC_F_BUSY: oc_flags = 2;
pub const oc_flags_OC_F_HFM: oc_flags = 4;
pub const oc_flags_OC_F_HFP: oc_flags = 8;
pub const oc_flags_OC_F_ABANDON: oc_flags = 16;
pub const oc_flags_OC_F_PRIVATE: oc_flags = 32;
pub const oc_flags_OC_F_FAILED: oc_flags = 64;
pub const oc_flags_OC_F_DYING: oc_flags = 128;
pub type oc_flags = ::std::os::raw::c_uint;
pub const oc_exp_flags_OC_EF_POSTED: oc_exp_flags = 2;
pub const oc_exp_flags_OC_EF_REFD: oc_exp_flags = 4;
pub const oc_exp_flags_OC_EF_MOVE: oc_exp_flags = 8;
pub const oc_exp_flags_OC_EF_INSERT: oc_exp_flags = 16;
pub const oc_exp_flags_OC_EF_REMOVE: oc_exp_flags = 32;
pub const oc_exp_flags_OC_EF_NEW: oc_exp_flags = 64;
pub type oc_exp_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore {
    pub magic: ::std::os::raw::c_uint,
    pub refcnt: ::std::os::raw::c_int,
    pub stobj: [storeobj; 1usize],
    pub objhead: *mut objhead,
    pub boc: *mut boc,
    pub timer_when: f64,
    pub hits: ::std::os::raw::c_long,
    pub t_origin: f64,
    pub ttl: f32,
    pub grace: f32,
    pub keep: f32,
    pub flags: u8,
    pub exp_flags: u8,
    pub oa_present: u16,
    pub timer_idx: ::std::os::raw::c_uint,
    pub last_lru: f64,
    pub hsh_list: objcore__bindgen_ty_1,
    pub lru_list: objcore__bindgen_ty_2,
    pub ban_list: objcore__bindgen_ty_3,
    pub exp_list: objcore__bindgen_ty_4,
    pub ban: *mut ban,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_1 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<objcore__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for objcore__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_2 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<objcore__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_2),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_2),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for objcore__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_3 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<objcore__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_3),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_3),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for objcore__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_4 {
    pub vstqe_next: *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<objcore__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vstqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_4),
            "::",
            stringify!(vstqe_next)
        )
    );
}
impl Default for objcore__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_objcore() {
    const UNINIT: ::std::mem::MaybeUninit<objcore> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<objcore>(),
        168usize,
        concat!("Size of: ", stringify!(objcore))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stobj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(stobj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objhead) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(objhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(boc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_when) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(timer_when)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hits) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_origin) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(t_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grace) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(grace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(keep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exp_flags) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(exp_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oa_present) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(oa_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_idx) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(timer_idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_lru) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(last_lru)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hsh_list) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(hsh_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lru_list) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(lru_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ban_list) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(ban_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exp_list) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(exp_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ban) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(ban)
        )
    );
}
impl Default for objcore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const director_state_e_DIR_S_NULL: director_state_e = 0;
pub const director_state_e_DIR_S_HDRS: director_state_e = 1;
pub const director_state_e_DIR_S_BODY: director_state_e = 2;
pub type director_state_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct busyobj {
    pub magic: ::std::os::raw::c_uint,
    pub end: *mut ::std::os::raw::c_char,
    pub retries: ::std::os::raw::c_int,
    pub req: *mut req,
    pub sp: *mut sess,
    pub wrk: *mut worker,
    pub vfc: *mut vfp_ctx,
    pub ws: [ws; 1usize],
    pub ws_bo: usize,
    pub bereq0: *mut http,
    pub bereq: *mut http,
    pub beresp: *mut http,
    pub stale_oc: *mut objcore,
    pub fetch_objcore: *mut objcore,
    pub htc: *mut http_conn,
    pub fetch_task: pool_task,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub connect_timeout: vtim_dur,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
    pub t_first: f64,
    pub t_prev: f64,
    pub acct: acct_bereq,
    pub storage: *const stevedore,
    pub director_req: *const director,
    pub director_resp: *const director,
    pub director_state: director_state_e,
    pub vcl: *mut vcl,
    pub vsl: [vsl_log; 1usize],
    pub digest: [u8; 32usize],
    pub privs: [vrt_privs; 1usize],
    pub err_code: u16,
    pub err_reason: *const ::std::os::raw::c_char,
    pub initial_req_body_status: req_body_state_e,
    pub bereq_body: *mut objcore,
}
#[test]
fn bindgen_test_layout_busyobj() {
    const UNINIT: ::std::mem::MaybeUninit<busyobj> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<busyobj>(),
        424usize,
        concat!("Size of: ", stringify!(busyobj))
    );
    assert_eq!(
        ::std::mem::align_of::<busyobj>(),
        8usize,
        concat!("Alignment of ", stringify!(busyobj))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retries) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(retries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrk) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(wrk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vfc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(ws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws_bo) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(ws_bo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq0) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(bereq0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(bereq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beresp) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(beresp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stale_oc) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(stale_oc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fetch_objcore) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(fetch_objcore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htc) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(htc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fetch_task) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(fetch_task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_timeout) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(connect_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_byte_timeout) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(first_byte_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).between_bytes_timeout) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(between_bytes_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_first) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(t_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_prev) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(t_prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acct) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(acct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).director_req) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(director_req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).director_resp) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(director_resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).director_state) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(director_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).privs) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(privs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_code) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_reason) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(err_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_req_body_status) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(initial_req_body_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bereq_body) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(bereq_body)
        )
    );
}
impl Default for busyobj {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl busyobj {
    #[inline]
    pub fn do_esi(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_esi(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_gzip(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_gzip(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_gunzip(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_gunzip(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_stream(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_stream(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_pass(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_pass(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uncacheable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uncacheable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn was_304(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_was_304(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_bgfetch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_bgfetch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        do_esi: ::std::os::raw::c_uint,
        do_gzip: ::std::os::raw::c_uint,
        do_gunzip: ::std::os::raw::c_uint,
        do_stream: ::std::os::raw::c_uint,
        do_pass: ::std::os::raw::c_uint,
        uncacheable: ::std::os::raw::c_uint,
        was_304: ::std::os::raw::c_uint,
        is_bgfetch: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let do_esi: u32 = unsafe { ::std::mem::transmute(do_esi) };
            do_esi as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_gzip: u32 = unsafe { ::std::mem::transmute(do_gzip) };
            do_gzip as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let do_gunzip: u32 = unsafe { ::std::mem::transmute(do_gunzip) };
            do_gunzip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let do_stream: u32 = unsafe { ::std::mem::transmute(do_stream) };
            do_stream as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let do_pass: u32 = unsafe { ::std::mem::transmute(do_pass) };
            do_pass as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let uncacheable: u32 = unsafe { ::std::mem::transmute(uncacheable) };
            uncacheable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let was_304: u32 = unsafe { ::std::mem::transmute(was_304) };
            was_304 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_bgfetch: u32 = unsafe { ::std::mem::transmute(is_bgfetch) };
            is_bgfetch as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req {
    pub magic: ::std::os::raw::c_uint,
    pub req_step: req_step,
    pub req_body_status: req_body_state_e,
    pub doclose: sess_close,
    pub restarts: ::std::os::raw::c_int,
    pub esi_level: ::std::os::raw::c_int,
    pub top: *mut req,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub err_code: u16,
    pub err_reason: *const ::std::os::raw::c_char,
    pub sp: *mut sess,
    pub wrk: *mut worker,
    pub task: pool_task,
    pub transport: *const transport,
    pub transport_priv: *mut ::std::os::raw::c_void,
    pub w_list: req__bindgen_ty_1,
    pub body_oc: *mut objcore,
    pub hash_objhead: *mut objhead,
    pub vary_b: *mut u8,
    pub vary_l: *mut u8,
    pub vary_e: *mut u8,
    pub digest: [u8; 32usize],
    pub d_ttl: f64,
    pub d_grace: f64,
    pub req_bodybytes: isize,
    pub storage: *const stevedore,
    pub director_hint: *const director,
    pub vcl: *mut vcl,
    pub ws_req: usize,
    pub t_first: f64,
    pub t_prev: f64,
    pub t_req: f64,
    pub htc: *mut http_conn,
    pub vfc: *mut vfp_ctx,
    pub client_identity: *const ::std::os::raw::c_char,
    pub http: *mut http,
    pub http0: *mut http,
    pub resp: *mut http,
    pub resp_len: intmax_t,
    pub ws: [ws; 1usize],
    pub objcore: *mut objcore,
    pub stale_oc: *mut objcore,
    pub vdc: *mut vdp_ctx,
    pub res_mode: ::std::os::raw::c_uint,
    pub vsl: [vsl_log; 1usize],
    pub acct: acct_req,
    pub privs: [vrt_privs; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req__bindgen_ty_1 {
    pub vtqe_next: *mut req,
    pub vtqe_prev: *mut *mut req,
}
#[test]
fn bindgen_test_layout_req__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<req__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<req__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(req__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<req__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(req__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(req__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(req__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for req__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_req() {
    const UNINIT: ::std::mem::MaybeUninit<req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<req>(),
        496usize,
        concat!("Size of: ", stringify!(req))
    );
    assert_eq!(
        ::std::mem::align_of::<req>(),
        8usize,
        concat!("Alignment of ", stringify!(req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_step) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(req_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_body_status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(req_body_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doclose) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(doclose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).restarts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(restarts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esi_level) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(esi_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(top))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_code) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_reason) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(err_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(sp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrk) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(wrk))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(task))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport_priv) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(transport_priv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_list) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(w_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_oc) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(body_oc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash_objhead) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(hash_objhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vary_b) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(vary_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vary_l) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(vary_l)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vary_e) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(vary_e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_ttl) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(d_ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_grace) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(d_grace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req_bodybytes) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(req_bodybytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).director_hint) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(director_hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl) as usize - ptr as usize },
        240usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vcl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws_req) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(ws_req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_first) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_prev) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_req) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htc) as usize - ptr as usize },
        280usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(htc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfc) as usize - ptr as usize },
        288usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vfc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_identity) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(client_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http) as usize - ptr as usize },
        304usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(http))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http0) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(http0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp) as usize - ptr as usize },
        320usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(resp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_len) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(resp_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        336usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(ws))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objcore) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(objcore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stale_oc) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(stale_oc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdc) as usize - ptr as usize },
        392usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vdc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res_mode) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(res_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsl) as usize - ptr as usize },
        408usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vsl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acct) as usize - ptr as usize },
        440usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(acct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).privs) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(privs)
        )
    );
}
impl Default for req {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl req {
    #[inline]
    pub fn disable_esi(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_esi(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_ignore_busy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_ignore_busy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_always_miss(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_always_miss(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitmiss(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitmiss(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitpass(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitpass(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waitinglist(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waitinglist(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want100cont(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want100cont(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn late100cont(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_late100cont(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_esi: ::std::os::raw::c_uint,
        hash_ignore_busy: ::std::os::raw::c_uint,
        hash_always_miss: ::std::os::raw::c_uint,
        is_hit: ::std::os::raw::c_uint,
        is_hitmiss: ::std::os::raw::c_uint,
        is_hitpass: ::std::os::raw::c_uint,
        waitinglist: ::std::os::raw::c_uint,
        want100cont: ::std::os::raw::c_uint,
        late100cont: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_esi: u32 = unsafe { ::std::mem::transmute(disable_esi) };
            disable_esi as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hash_ignore_busy: u32 = unsafe { ::std::mem::transmute(hash_ignore_busy) };
            hash_ignore_busy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hash_always_miss: u32 = unsafe { ::std::mem::transmute(hash_always_miss) };
            hash_always_miss as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_hit: u32 = unsafe { ::std::mem::transmute(is_hit) };
            is_hit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_hitmiss: u32 = unsafe { ::std::mem::transmute(is_hitmiss) };
            is_hitmiss as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_hitpass: u32 = unsafe { ::std::mem::transmute(is_hitpass) };
            is_hitpass as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let waitinglist: u32 = unsafe { ::std::mem::transmute(waitinglist) };
            waitinglist as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let want100cont: u32 = unsafe { ::std::mem::transmute(want100cont) };
            want100cont as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let late100cont: u32 = unsafe { ::std::mem::transmute(late100cont) };
            late100cont as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const sess_attr_SA_TRANSPORT: sess_attr = 0;
pub const sess_attr_SA_REMOTE_ADDR: sess_attr = 1;
pub const sess_attr_SA_LOCAL_ADDR: sess_attr = 2;
pub const sess_attr_SA_CLIENT_ADDR: sess_attr = 3;
pub const sess_attr_SA_SERVER_ADDR: sess_attr = 4;
pub const sess_attr_SA_CLIENT_IP: sess_attr = 5;
pub const sess_attr_SA_CLIENT_PORT: sess_attr = 6;
pub const sess_attr_SA_PROXY_TLV: sess_attr = 7;
pub const sess_attr_SA_PROTO_PRIV: sess_attr = 8;
pub const sess_attr_SA_LAST: sess_attr = 9;
pub type sess_attr = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sess {
    pub magic: ::std::os::raw::c_uint,
    pub sattr: [u16; 9usize],
    pub listen_sock: *mut listen_sock,
    pub refcnt: ::std::os::raw::c_int,
    pub fd: ::std::os::raw::c_int,
    pub vxid: u32,
    pub mtx: lock,
    pub pool: *mut pool,
    pub ws: [ws; 1usize],
    pub t_open: vtim_real,
    pub t_idle: vtim_real,
    pub timeout_idle: vtim_dur,
}
#[test]
fn bindgen_test_layout_sess() {
    const UNINIT: ::std::mem::MaybeUninit<sess> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sess>(),
        128usize,
        concat!("Size of: ", stringify!(sess))
    );
    assert_eq!(
        ::std::mem::align_of::<sess>(),
        8usize,
        concat!("Alignment of ", stringify!(sess))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sattr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(sattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listen_sock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(listen_sock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        36usize,
        concat!("Offset of field: ", stringify!(sess), "::", stringify!(fd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vxid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(vxid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtx) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(sess), "::", stringify!(mtx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(sess), "::", stringify!(ws))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_open) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(t_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_idle) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(t_idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_idle) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(timeout_idle)
        )
    );
}
impl Default for sess {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn BAN_Build() -> *mut ban_proto;
}
extern "C" {
    pub fn BAN_AddTest(
        arg1: *mut ban_proto,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BAN_Commit(b: *mut ban_proto) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BAN_Abandon(b: *mut ban_proto);
}
extern "C" {
    pub static mut cli_thread: pthread_t;
}
extern "C" {
    pub fn HTTP_estimate(nhttp: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn HTTP_Copy(to: *mut http, fm: *const http);
}
extern "C" {
    pub fn HTTP_create(
        p: *mut ::std::os::raw::c_void,
        nhttp: u16,
        arg1: ::std::os::raw::c_uint,
    ) -> *mut http;
}
extern "C" {
    pub fn http_Status2Reason(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_EstimateWS(fm: *const http, how: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn http_PutResponse(
        to: *mut http,
        proto: *const ::std::os::raw::c_char,
        status: u16,
        response: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn http_FilterReq(to: *mut http, fm: *const http, how: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn HTTP_Encode(
        fm: *const http,
        arg1: *mut u8,
        len: ::std::os::raw::c_uint,
        how: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn HTTP_Decode(to: *mut http, fm: *const u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_ForceHeader(
        to: *mut http,
        hdr: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn http_PrintfHeader(to: *mut http, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn http_TimeHeader(to: *mut http, fmt: *const ::std::os::raw::c_char, now: f64);
}
extern "C" {
    pub fn http_Proto(to: *mut http);
}
extern "C" {
    pub fn http_SetHeader(to: *mut http, hdr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_SetH(to: *mut http, n: ::std::os::raw::c_uint, fm: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_ForceField(
        to: *mut http,
        n: ::std::os::raw::c_uint,
        t: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn HTTP_Setup(arg1: *mut http, arg2: *mut ws, arg3: *mut vsl_log, arg4: VSL_tag_e);
}
extern "C" {
    pub fn http_Teardown(ht: *mut http);
}
extern "C" {
    pub fn http_GetHdr(
        hp: *const http,
        hdr: *const ::std::os::raw::c_char,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_GetHdrToken(
        hp: *const http,
        hdr: *const ::std::os::raw::c_char,
        token: *const ::std::os::raw::c_char,
        pb: *mut *const ::std::os::raw::c_char,
        pe: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_GetHdrField(
        hp: *const http,
        hdr: *const ::std::os::raw::c_char,
        field: *const ::std::os::raw::c_char,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_GetHdrQ(
        hp: *const http,
        hdr: *const ::std::os::raw::c_char,
        field: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn http_GetContentLength(hp: *const http) -> isize;
}
extern "C" {
    pub fn http_GetStatus(hp: *const http) -> u16;
}
extern "C" {
    pub fn http_IsStatus(hp: *const http, arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_SetStatus(to: *mut http, status: u16);
}
extern "C" {
    pub fn http_GetMethod(hp: *const http) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_HdrIs(
        hp: *const http,
        hdr: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_CopyHome(hp: *const http);
}
extern "C" {
    pub fn http_Unset(hp: *mut http, hdr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_CountHdr(
        hp: *const http,
        hdr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn http_CollectHdr(hp: *mut http, hdr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_CollectHdrSep(
        hp: *mut http,
        hdr: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn http_VSL_log(hp: *const http);
}
extern "C" {
    pub fn HTTP_Merge(arg1: *mut worker, arg2: *mut objcore, to: *mut http);
}
extern "C" {
    pub fn HTTP_GetStatusPack(arg1: *mut worker, oc: *mut objcore) -> u16;
}
extern "C" {
    pub fn HTTP_IterHdrPack(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HTTP_GetHdrPack(
        arg1: *mut worker,
        arg2: *mut objcore,
        hdr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_DoConnection(hp: *mut http) -> sess_close;
}
extern "C" {
    pub fn http_IsFiltered(
        hp: *const http,
        u: ::std::os::raw::c_uint,
        how: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut H_Accept: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Charset: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Encoding: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Language: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Ranges: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Age: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Allow: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Authorization: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Cache_Control: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Connection: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Encoding: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Language: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Length: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Location: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_MD5: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Range: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Type: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Cookie: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Date: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_ETag: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Expect: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Expires: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_From: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Host: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_HTTP2_Settings: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Match: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Modified_Since: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_None_Match: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Range: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Unmodified_Since: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Keep_Alive: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Last_Modified: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Location: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Max_Forwards: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Pragma: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Proxy_Authenticate: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Proxy_Authorization: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Range: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Referer: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Retry_After: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Server: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Set_Cookie: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_TE: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Trailer: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Transfer_Encoding: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Upgrade: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_User_Agent: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Vary: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Via: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Warning: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_WWW_Authenticate: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_X_Forwarded_For: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static H__Status: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static H__Proto: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static H__Reason: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn VXID_Get(arg1: *mut worker, marker: u32) -> u32;
}
extern "C" {
    pub static mut witness_key: pthread_key_t;
}
extern "C" {
    pub fn Lck__Lock(lck: *mut lock, p: *const ::std::os::raw::c_char, l: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Lck__Unlock(lck: *mut lock, p: *const ::std::os::raw::c_char, l: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Lck__Trylock(
        lck: *mut lock,
        p: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck__New(lck: *mut lock, arg1: *mut VSC_lck, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn Lck__Held(lck: *const lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck__Owned(lck: *const lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck_Delete(lck: *mut lock);
}
extern "C" {
    pub fn Lck_CondWait(
        cond: *mut pthread_cond_t,
        lck: *mut lock,
        arg1: vtim_real,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck_CreateClass(
        arg1: *mut *mut vsc_seg,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut VSC_lck;
}
extern "C" {
    pub fn Lck_DestroyClass(arg1: *mut *mut vsc_seg);
}
extern "C" {
    pub static mut lck_backend: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_ban: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_busyobj: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_cli: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_exp: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_hcb: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_lru: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_mempool: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_objhdr: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_pipestat: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_sess: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_tcp_pool: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vbe: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vcapace: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vcl: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vxid: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_waiter: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_wq: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_wstat: *mut VSC_lck;
}
extern "C" {
    pub fn ObjHasAttr(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetAttr(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        len: *mut isize,
    ) -> *const ::std::os::raw::c_void;
}
pub type objiterate_f = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        flush: ::std::os::raw::c_int,
        ptr: *const ::std::os::raw::c_void,
        len: isize,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ObjIterate(
        arg1: *mut worker,
        arg2: *mut objcore,
        priv_: *mut ::std::os::raw::c_void,
        func: objiterate_f,
        final_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetXID(arg1: *mut worker, arg2: *mut objcore) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ObjGetLen(arg1: *mut worker, arg2: *mut objcore) -> u64;
}
extern "C" {
    pub fn ObjGetDouble(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetU32(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetU64(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjCheckFlag(
        arg1: *mut worker,
        arg2: *mut objcore,
        of: obj_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_remote_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_local_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_client_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_server_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_client_ip(
        sp: *const sess,
        dst: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_client_port(
        sp: *const sess,
        dst: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_proxy_tlv(sp: *const sess, dst: *mut *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_proto_priv(sp: *const sess, dst: *mut *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_String_Attr(sp: *const sess, a: sess_attr) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VSLv(
        tag: VSL_tag_e,
        vxid: u32,
        fmt: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn VSL(tag: VSL_tag_e, vxid: u32, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VSLbv(
        arg1: *mut vsl_log,
        tag: VSL_tag_e,
        fmt: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn VSLb(arg1: *mut vsl_log, tag: VSL_tag_e, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VSLbt(arg1: *mut vsl_log, tag: VSL_tag_e, t: txt);
}
extern "C" {
    pub fn VSLb_ts(
        arg1: *mut vsl_log,
        event: *const ::std::os::raw::c_char,
        first: f64,
        pprev: *mut f64,
        now: f64,
    );
}
extern "C" {
    pub fn VSLb_bin(
        arg1: *mut vsl_log,
        arg2: VSL_tag_e,
        arg3: isize,
        arg4: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn VCL_Name(arg1: *const vcl) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VRT_String(
        ws: *mut ws,
        h: *const ::std::os::raw::c_char,
        p: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VRT_StringList(
        d: *mut ::std::os::raw::c_char,
        dl: ::std::os::raw::c_uint,
        p: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
pub type bgthread_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut worker,
        priv_: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn WRK_BgThread(
        thr: *mut pthread_t,
        name: *const ::std::os::raw::c_char,
        func: bgthread_t,
        priv_: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn WS_Init(
        ws: *mut ws,
        id: *const ::std::os::raw::c_char,
        space: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn WS_Reserve(ws: *mut ws, bytes: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_ReserveSize(arg1: *mut ws, arg2: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_ReserveAll(arg1: *mut ws) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_ReserveLumps(ws: *mut ws, sz: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_MarkOverflow(ws: *mut ws);
}
extern "C" {
    pub fn WS_Release(ws: *mut ws, bytes: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn WS_ReleaseP(ws: *mut ws, ptr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn WS_Assert(ws: *const ws);
}
extern "C" {
    pub fn WS_Reset(ws: *mut ws, arg1: usize);
}
extern "C" {
    pub fn WS_Alloc(ws: *mut ws, bytes: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn WS_Copy(
        ws: *mut ws,
        str_: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn WS_Snapshot(ws: *mut ws) -> usize;
}
extern "C" {
    pub fn WS_Overflowed(ws: *const ws) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WS_Printf(
        ws: *mut ws,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn WS_Inside(
        arg1: *const ws,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WS_Assert_Allocated(ws: *const ws, ptr: *const ::std::os::raw::c_void, len: isize);
}
extern "C" {
    pub fn RFC2616_Ttl(
        arg1: *mut busyobj,
        now: f64,
        t_origin: *mut f64,
        ttl: *mut f32,
        grace: *mut f32,
        keep: *mut f32,
    );
}
extern "C" {
    pub fn RFC2616_Req_Gzip(arg1: *const http) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn RFC2616_Do_Cond(sp: *const req) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RFC2616_Weaken_Etag(hp: *mut http);
}
extern "C" {
    pub fn RFC2616_Vary_AE(hp: *mut http);
}
extern "C" {
    pub fn RFC2616_Response_Body(arg1: *const worker, arg2: *const busyobj);
}
pub type vdi_healthy_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const director,
        arg2: *const busyobj,
        changed: *mut f64,
    ) -> ::std::os::raw::c_uint,
>;
pub type vdi_resolve_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const director,
        arg2: *mut worker,
        arg3: *mut busyobj,
    ) -> *const director,
>;
pub type vdi_gethdrs_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const director,
        arg2: *mut worker,
        arg3: *mut busyobj,
    ) -> ::std::os::raw::c_int,
>;
pub type vdi_getbody_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const director,
        arg2: *mut worker,
        arg3: *mut busyobj,
    ) -> ::std::os::raw::c_int,
>;
pub type vdi_getip_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const director,
        arg2: *mut worker,
        arg3: *mut busyobj,
    ) -> *const suckaddr,
>;
pub type vdi_finish_f = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const director, arg2: *mut worker, arg3: *mut busyobj),
>;
pub type vdi_http1pipe_f = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const director, arg2: *mut req, arg3: *mut busyobj) -> sess_close,
>;
pub type vdi_event_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const director, arg2: vcl_event_e)>;
pub type vdi_destroy_f = ::std::option::Option<unsafe extern "C" fn(arg1: *const director)>;
pub type vdi_panic_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const director, arg2: *mut vsb)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct director {
    pub magic: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub vcl_name: *mut ::std::os::raw::c_char,
    pub http1pipe: vdi_http1pipe_f,
    pub healthy: vdi_healthy_f,
    pub resolve: vdi_resolve_f,
    pub gethdrs: vdi_gethdrs_f,
    pub getbody: vdi_getbody_f,
    pub getip: vdi_getip_f,
    pub finish: vdi_finish_f,
    pub event: vdi_event_f,
    pub destroy: vdi_destroy_f,
    pub panic: vdi_panic_f,
    pub priv_: *mut ::std::os::raw::c_void,
    pub priv2: *const ::std::os::raw::c_void,
    pub display_name: *mut ::std::os::raw::c_char,
    pub vcl_list: director__bindgen_ty_1,
    pub vcl: *mut vcl,
    pub health: ::std::os::raw::c_uint,
    pub admin_health: *mut vdi_ahealth,
    pub health_changed: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct director__bindgen_ty_1 {
    pub vtqe_next: *mut director,
    pub vtqe_prev: *mut *mut director,
}
#[test]
fn bindgen_test_layout_director__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<director__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<director__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(director__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<director__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(director__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(director__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(director__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for director__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_director() {
    const UNINIT: ::std::mem::MaybeUninit<director> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<director>(),
        176usize,
        concat!("Size of: ", stringify!(director))
    );
    assert_eq!(
        ::std::mem::align_of::<director>(),
        8usize,
        concat!("Alignment of ", stringify!(director))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(vcl_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).http1pipe) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(http1pipe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).healthy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(healthy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolve) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(resolve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gethdrs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(gethdrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getbody) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(getbody)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getip) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(getip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finish) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).panic) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(panic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv2) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(priv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_name) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl_list) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(vcl_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcl) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(vcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).health) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(health)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).admin_health) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(admin_health)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).health_changed) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(health_changed)
        )
    );
}
impl Default for director {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VDI_Healthy(arg1: *const director, arg2: *mut f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn VCL_AddDirector(
        arg1: *mut vcl,
        arg2: *mut director,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VCL_DelDirector(arg1: *mut director);
}
extern "C" {
    pub static VDI_AH_HEALTHY: *const vdi_ahealth;
}
extern "C" {
    pub static VDI_AH_SICK: *const vdi_ahealth;
}
extern "C" {
    pub static VDI_AH_PROBE: *const vdi_ahealth;
}
extern "C" {
    pub static VDI_AH_DELETED: *const vdi_ahealth;
}
extern "C" {
    pub fn VDI_Ahealth(d: *const director) -> *const ::std::os::raw::c_char;
}
pub const vfp_status_VFP_ERROR: vfp_status = -1;
pub const vfp_status_VFP_OK: vfp_status = 0;
pub const vfp_status_VFP_END: vfp_status = 1;
pub const vfp_status_VFP_NULL: vfp_status = 2;
pub type vfp_status = ::std::os::raw::c_int;
pub type vfp_init_f = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut vfp_ctx, arg2: *mut vfp_entry) -> vfp_status,
>;
pub type vfp_pull_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vfp_ctx,
        arg2: *mut vfp_entry,
        ptr: *mut ::std::os::raw::c_void,
        len: *mut isize,
    ) -> vfp_status,
>;
pub type vfp_fini_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut vfp_ctx, arg2: *mut vfp_entry)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp {
    pub name: *const ::std::os::raw::c_char,
    pub init: vfp_init_f,
    pub pull: vfp_pull_f,
    pub fini: vfp_fini_f,
    pub priv1: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vfp() {
    const UNINIT: ::std::mem::MaybeUninit<vfp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp>(),
        40usize,
        concat!("Size of: ", stringify!(vfp))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pull) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(pull))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fini) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(fini))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp),
            "::",
            stringify!(priv1)
        )
    );
}
impl Default for vfp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry {
    pub magic: ::std::os::raw::c_uint,
    pub vfp: *const vfp,
    pub priv1: *mut ::std::os::raw::c_void,
    pub priv2: isize,
    pub closed: vfp_status,
    pub list: vfp_entry__bindgen_ty_1,
    pub calls: u64,
    pub bytes_out: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry__bindgen_ty_1 {
    pub vtqe_next: *mut vfp_entry,
    pub vtqe_prev: *mut *mut vfp_entry,
}
#[test]
fn bindgen_test_layout_vfp_entry__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vfp_entry__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp_entry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vfp_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for vfp_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vfp_entry() {
    const UNINIT: ::std::mem::MaybeUninit<vfp_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp_entry>(),
        72usize,
        concat!("Size of: ", stringify!(vfp_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(vfp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(priv1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(priv2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(closed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calls) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(calls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_out) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(bytes_out)
        )
    );
}
impl Default for vfp_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry_s {
    pub vtqh_first: *mut vfp_entry,
    pub vtqh_last: *mut *mut vfp_entry,
}
#[test]
fn bindgen_test_layout_vfp_entry_s() {
    const UNINIT: ::std::mem::MaybeUninit<vfp_entry_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp_entry_s>(),
        16usize,
        concat!("Size of: ", stringify!(vfp_entry_s))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_entry_s>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_entry_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry_s),
            "::",
            stringify!(vtqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry_s),
            "::",
            stringify!(vtqh_last)
        )
    );
}
impl Default for vfp_entry_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub failed: ::std::os::raw::c_int,
    pub req: *mut http,
    pub resp: *mut http,
    pub wrk: *mut worker,
    pub oc: *mut objcore,
    pub vfp: vfp_entry_s,
    pub vfp_nxt: *mut vfp_entry,
    pub obj_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vfp_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<vfp_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vfp_ctx>(),
        72usize,
        concat!("Size of: ", stringify!(vfp_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).req) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrk) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(wrk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(oc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(vfp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfp_nxt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(vfp_nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj_flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(obj_flags)
        )
    );
}
impl Default for vfp_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VFP_Suck(
        arg1: *mut vfp_ctx,
        p: *mut ::std::os::raw::c_void,
        lp: *mut isize,
    ) -> vfp_status;
}
extern "C" {
    pub fn VFP_Error(arg1: *mut vfp_ctx, fmt: *const ::std::os::raw::c_char, ...) -> vfp_status;
}
pub const vdp_action_VDP_NULL: vdp_action = 0;
pub const vdp_action_VDP_FLUSH: vdp_action = 1;
pub type vdp_action = ::std::os::raw::c_uint;
pub type vdp_init_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut req,
        priv_: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type vdp_fini_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut req,
        priv_: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type vdp_bytes_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut req,
        arg2: vdp_action,
        priv_: *mut *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
        len: isize,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp {
    pub name: *const ::std::os::raw::c_char,
    pub init: vdp_init_f,
    pub bytes: vdp_bytes_f,
    pub fini: vdp_fini_f,
}
#[test]
fn bindgen_test_layout_vdp() {
    const UNINIT: ::std::mem::MaybeUninit<vdp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp>(),
        32usize,
        concat!("Size of: ", stringify!(vdp))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(vdp), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(vdp), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fini) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(vdp), "::", stringify!(fini))
    );
}
impl Default for vdp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry {
    pub magic: ::std::os::raw::c_uint,
    pub vdp: *const vdp,
    pub priv_: *mut ::std::os::raw::c_void,
    pub list: vdp_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry__bindgen_ty_1 {
    pub vtqe_next: *mut vdp_entry,
    pub vtqe_prev: *mut *mut vdp_entry,
}
#[test]
fn bindgen_test_layout_vdp_entry__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vdp_entry__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp_entry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vdp_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for vdp_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vdp_entry() {
    const UNINIT: ::std::mem::MaybeUninit<vdp_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp_entry>(),
        40usize,
        concat!("Size of: ", stringify!(vdp_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(vdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(list)
        )
    );
}
impl Default for vdp_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry_s {
    pub vtqh_first: *mut vdp_entry,
    pub vtqh_last: *mut *mut vdp_entry,
}
#[test]
fn bindgen_test_layout_vdp_entry_s() {
    const UNINIT: ::std::mem::MaybeUninit<vdp_entry_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp_entry_s>(),
        16usize,
        concat!("Size of: ", stringify!(vdp_entry_s))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_entry_s>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_entry_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry_s),
            "::",
            stringify!(vtqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry_s),
            "::",
            stringify!(vtqh_last)
        )
    );
}
impl Default for vdp_entry_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub vdp: vdp_entry_s,
    pub nxt: *mut vdp_entry,
    pub retval: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vdp_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<vdp_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vdp_ctx>(),
        40usize,
        concat!("Size of: ", stringify!(vdp_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(vdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nxt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(retval)
        )
    );
}
impl Default for vdp_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VDP_bytes(
        arg1: *mut req,
        act: vdp_action,
        ptr: *const ::std::os::raw::c_void,
        len: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VDP_Push(
        arg1: *mut req,
        arg2: *const vdp,
        priv_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_AddVDP(ctx: *const vrt_ctx, arg1: *const vdp);
}
extern "C" {
    pub fn VRT_RemoveVDP(ctx: *const vrt_ctx, arg1: *const vdp);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsb {
    pub magic: ::std::os::raw::c_uint,
    pub s_error: ::std::os::raw::c_int,
    pub s_buf: *mut ::std::os::raw::c_char,
    pub s_size: isize,
    pub s_len: isize,
    pub s_flags: ::std::os::raw::c_int,
    pub s_indent: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vsb() {
    const UNINIT: ::std::mem::MaybeUninit<vsb> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vsb>(),
        40usize,
        concat!("Size of: ", stringify!(vsb))
    );
    assert_eq!(
        ::std::mem::align_of::<vsb>(),
        8usize,
        concat!("Alignment of ", stringify!(vsb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_error) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_indent) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_indent)
        )
    );
}
impl Default for vsb {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VSB_new(
        arg1: *mut vsb,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut vsb;
}
extern "C" {
    pub fn VSB_clear(arg1: *mut vsb);
}
extern "C" {
    pub fn VSB_bcat(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_void,
        arg3: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_cat(arg1: *mut vsb, arg2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_printf(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_vprintf(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_putc(arg1: *mut vsb, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_error(arg1: *const vsb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_finish(arg1: *mut vsb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_data(arg1: *const vsb) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn VSB_len(arg1: *const vsb) -> isize;
}
extern "C" {
    pub fn VSB_delete(arg1: *mut vsb);
}
extern "C" {
    pub fn VSB_destroy(arg1: *mut *mut vsb);
}
extern "C" {
    pub fn VSB_quote_pfx(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        how: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn VSB_quote(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        how: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn VSB_indent(arg1: *mut vsb, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn VSB_tofile(arg1: *const vsb, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static vsa_suckaddr_len: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut bogo_ip: *const suckaddr;
}
extern "C" {
    pub fn VSA_Init();
}
extern "C" {
    pub fn VSA_Sane(arg1: *const suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSA_Port(arg1: *const suckaddr) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn VSA_Compare(arg1: *const suckaddr, arg2: *const suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSA_Compare_IP(arg1: *const suckaddr, arg2: *const suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSA_Clone(sua: *const suckaddr) -> *mut suckaddr;
}
extern "C" {
    pub fn VSA_Get_Sockaddr(
        arg1: *const suckaddr,
        sl: *mut socklen_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn VSA_Get_Proto(arg1: *const suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSA_Malloc(
        s: *const ::std::os::raw::c_void,
        sal: ::std::os::raw::c_uint,
    ) -> *mut suckaddr;
}
extern "C" {
    pub fn VSA_Build(
        d: *mut ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        sal: ::std::os::raw::c_uint,
    ) -> *mut suckaddr;
}
extern "C" {
    pub fn VSA_GetPtr(
        sua: *const suckaddr,
        dst: *mut *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_conn {
    pub magic: ::std::os::raw::c_uint,
    pub rfd: *mut ::std::os::raw::c_int,
    pub doclose: sess_close,
    pub body_status: body_status,
    pub ws: *mut ws,
    pub rxbuf_b: *mut ::std::os::raw::c_char,
    pub rxbuf_e: *mut ::std::os::raw::c_char,
    pub pipeline_b: *mut ::std::os::raw::c_char,
    pub pipeline_e: *mut ::std::os::raw::c_char,
    pub content_length: isize,
    pub priv_: *mut ::std::os::raw::c_void,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
}
#[test]
fn bindgen_test_layout_http_conn() {
    const UNINIT: ::std::mem::MaybeUninit<http_conn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<http_conn>(),
        96usize,
        concat!("Size of: ", stringify!(http_conn))
    );
    assert_eq!(
        ::std::mem::align_of::<http_conn>(),
        8usize,
        concat!("Alignment of ", stringify!(http_conn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(rfd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doclose) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(doclose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(body_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ws) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(ws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxbuf_b) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(rxbuf_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxbuf_e) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(rxbuf_e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipeline_b) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(pipeline_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipeline_e) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(pipeline_e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_length) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(content_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_byte_timeout) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(first_byte_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).between_bytes_timeout) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(between_bytes_timeout)
        )
    );
}
impl Default for http_conn {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VFP_Push(arg1: *mut vfp_ctx, arg2: *const vfp) -> *mut vfp_entry;
}
extern "C" {
    pub fn VRB_Iterate(
        req: *mut req,
        func: objiterate_f,
        priv_: *mut ::std::os::raw::c_void,
    ) -> isize;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vrt_priv {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v1l {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vdi_ahealth {
    pub _address: u8,
}
